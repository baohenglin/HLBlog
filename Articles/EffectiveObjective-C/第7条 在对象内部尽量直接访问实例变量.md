## 第7条 在对象内部尽量直接访问实例变量

### 要点：

* 在对象内部读取数据时，应该直接通过实例变量来读取，而写入数据时，则应通过属性来写。
* 在初始化方法及 dealloc 方法中，总是应该直接通过实例变量来读写数据。
* 有时会使用惰性初始化技术配置某份数据，这种情况下，需要通过属性来读取数据。

在对象之外访问实例变量时，总是应该通过属性来做，然而在对象内部访问实例变量时又该如何呢？

Objective-C的开发者们一直在激烈争论这个问题。有人认为，无论什么情况，都应该通过属性来访问实例变量；也有人说，“通过属性访问”与“直接访问”这两种做法应该搭配着用。**除了几种特殊情况之外，笔者强烈建议大家在读取实例变量时采用直接访问的形式，而在设置实例变量时通过属性来做**。

```
@interface EOCPerson : NSObject
@property (nonatomic, copy) NSString *firstName;
@property (nonatomic, copy) NSString *lastName;
- (NSString *)fullName;
- (void)setFullName:(NSString *)fullName;
@end
```

fullName 与 setFullName 这两个“便捷方法”可以这样来实现：

```
- (NSString *)fullName {
    return [NSString stringWithFormat:@"%@ %@",self.firstName, self.lastName];
}
- (void)setFullName:(NSString *)fullName {
    NSArray *components = [fullName componentsSeparatedByString:@" "];
    self.firstName = [components objectAtIndex:0];
    self.lastName = [components objectAtIndex:1];
}
```

上面示例中，在 fullName 的获取方法与设置方法中，我们使用“点语法”，通过存取方法来访问相关实例变量。现在假设重写这两个方法，不经由存取方法，而是直接访问实例变量：

```
- (NSString *)fullName {
    return [NSString stringWithFormat:@"%@ %@",_firstName, _lastName];
}
- (void)setFullName:(NSString *)fullName {
    NSArray *components = [fullName componentsSeparatedByString:@" "];
    _firstName = [components objectAtIndex:0];
    _lastName = [components objectAtIndex:1];
}
```

这两种写法有几个区别：

* 由于不经过 Objective-C 的“方法派发”（method dispatch 参见第11条）步骤，所以直接访问实例变量的速度当然比较快。在这种情况下，编译器所生成的代码会直接访问保存对象实例变量的那块内存。
* 直接访问实例变量时，不会调用其“设置方法”，这就绕过了为相关属性所定义的“内存管理语义”。比如说，如果在 ARC 下直接访问一个声明为 copy 的属性，那么并不会拷贝该属性，只会保留新值并释放旧值。
* 如果直接访问实例变量，那么不会触发“键值观察”（Key-Value Observing,KVO）通知。这样做是否会产生问题，还取决于具体的对象行为。
* 通过属性来访问有助于排查与之相关的错误，因为可以给“获取方法”或者“设置方法”中新增“断点”（breakpoint），监控该属性的调用者及其访问时机。
