# 第四章 协议与分类

## 第 23 条 通过委托与数据源协议进行对象间通信

### 要点

* 委托模式为对象提供了一套接口，使其可由此将相关事件告知其他对象。
* 将委托对象应该支持的接口定义成协议，在协议中把可能需要处理的事件定义成方法。
* 当某对象需要从另外一个对象中获取数据时，可以使用委托模式。这种情景下，该模式也称“数据源协议”（data source protocol）。
* 若有必要，可实现含有位段的结构体，将委托对象是否能响应相关协议方法这一信息缓存至其中。

Objective-C语言的“**协议**”（protocol）与 Java 的“接口”（interface）类似。Objective-C不支持多重继承，因而我们把某个类应该实现的一系列方法定义在协议里面。协议最为常见的用途是实现委托模式（参见第 23 条），不过也有其他用法。理解并**善用协议可令代码变得更易维护**，因为协议这种方式能很好地描述接口。

**分类**（Category）也是 Objective-C 的一项重要语言特性。利用分类机制，我们无须继承子类即可直接为当前类添加方法，而在其他编程语言中，则需通过继承子类来实现。由于 Objective-C 运行期系统是高度动态的，所以才能支持这一特性。然而，其中也隐藏着一些陷阱，因此在使用分类之前，应该先理解它。

对象之间经常需要通信，而通信方式有很多种。Objective-C 开发者广泛使用一种名叫“委托模式（Delegate pattern）”的编程设计模式来实现对象间的通信，该模式的主旨是：**定义一套接口，某对象若想接受另一个对象的委托，则需遵从此接口，以便成为其“委托对象”（delegate）。而这“另一个对象”则可以给其委托对象回传一些信息，也可以在发生相关事件时通知委托对象**。

此模式**可将数据与业务逻辑解耦**。比方说，用户界面里有个显示一系列数据所用的视图，那么，此**视图只应包含显示数据所需的逻辑代码，而不应决定要显示何种数据以及数据之间如何交互等问题**。视图对象的属性中，可以包含负责数据与事件处理的对象。这两种对象分别称为“数据源”（data source）与“委托”（delegate）。

在 Objective-C中，一般通过“协议”这项语言特性来实现此模式，整个 **Cocoa 系统框架**都是这么做的。如果你的代码也这样写，那么就能和系统框架很好地融合在一起了。

为了演示此模式，我们举个例子，假设要编写一个从网上获取数据的类。此类也许要从远程服务器的某个资源里获取数据。那个远程服务器可能过很长时间才会应答，而在获取数据的过程中阻塞应用程序则是一种非常糟糕的做法。于是，在这种情况下，我们通常会使用委托模式：获取网络数据的类含有一个“委托对象”，在获取完整数据之后，它会回调这个委托对象。

图 4-1 演示了此概念：EOCDataModel 对象就是 EOCNetworkFetcher 的委托对象。EOCDataModel请求 EOCNetworkFetcher“以异步方式执行一项任务”（perform a task asynchronously），而 EOCNetworkFetcher 在执行完这项任务之后，就会通知其委托对象，也就是 EOCDataModel。

![image.png](https://upload-images.jianshu.io/upload_images/4164292-e0facb34e463914b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

利用协议机制，很容易就能以 Objective-C 代码实现此模式。协议可以这样来定义：

```
@protocol EOCNetworkFetcherDelegate
- (void)networkFetcher:(EOCNetworkFetcher*)fetcher
         didReceiveData:(NSData*)data;
- (void)networkFetcher:(EOCNetworkFetcher*)fetcher
         didFailWithError:(NSError*)error;
@end
```

委托协议名命名方式：相关类名+Delegate

有了这个协议之后，类就可以用一个属性来存放其委托对象了。在本类中，这个类就是 EOCNetworkFetcher 类。

```
@interface EOCNetworkFetcher : NSObject
@property (nonatomic, weak) id <EOCNetworkFetcherDelegate> delegate;
@end
```

【注意】这个属性一定要定义成 weak，而非 strong，因为两者之间必须为“非拥有关系”（nonowning relationship）。通常情况下，扮演 delegate 的那个对象也要持有本对象。例如在本例中，想使用 EOCNetworkFetcher 的那个对象就会持有本对象，直到用完本对象之后，才会释放。假如声明属性时用 strong 将本对象与委托对象之间定为“拥有关系”，那么就会引入“保留环”（retain cycle）。因此，本类中存放委托对象的这个属性要么定义成 weak，要么定义成 unsafe_unretained，如果需要在相关对象销毁时自动清空（autoniling，参见第6条），则定义为weak，若不需要自动清空，则定义为unsafe_unretained。







