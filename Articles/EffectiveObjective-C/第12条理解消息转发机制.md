# 第12条 理解消息转发机制

第11条讲解了对象的消息传递机制，并强调了其重要性。第12条则要讲解另外一个重要的问题，就是对象在收到无法解读的消息之后会发生什么情况。

如果想让类能理解某条消息，我们必须通过代码来实现其对应的方法。但是，在编译期向类发送了其无法解读的消息并不会报错，因为在运行期可以继续向类中添加方法，所以编译器在编译时还无法确定类中到底会不会有某个方法的实现。当对象接收到无法解读的消息后，就会启动“消息转发”(message forwarding)机制，程序员可经由此过程告诉对象该如何处理未知消息。

```
2019-08-07 18:47:22.014341+0800 InterviewQuestionsCollection[30209:1924891] -[HLPerson run]: unrecognized selector sent to instance 0x600002c7c4d0
2019-08-07 18:47:22.023878+0800 InterviewQuestionsCollection[30209:1924891] *** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[HLPerson run]: unrecognized selector sent to instance 0x600002c7c4d0'
```

上面的报错信息就是因为向实例对象发送了一条其无法解析的消息，从而启动了消息转发机制以应用程序崩溃而告终。不过，开发者在编写自己的类时，可以在转发过程中设置挂钩，用以执行预定的逻辑，而不使应用程序崩溃。

消息转发分为两大阶段。第一阶段先看接收者是否能动态添加方法，已处理当前这个“未知的选择子”，这叫做“动态方法解析”(dynamic method resolution)。第二阶段是“完整的消息转发机制”(full forwarding mechanism)。如果运行期系统已经把第一阶段执行完了，那么接收者自己就无法以动态新增方法的手段来响应包含该选择子的消息了。此时，运行期系统会请求接收者以其他手段来处理与消息相关的方法调用。这又细分为两小步。首先，请接收者看看有没有其他对象能处理这条消息。如果有，则运行期系统会把该消息转发给那个对象，于是消息转发过程结束，一切如常。如果没有“备援的接收者”(replacement receiver)，则启动完整的消息转发机制，运行期系统会把与消息有关的全部细节都封装到NSInvocation对象中，再给接收者最后一次机会，令其设法解决当前还未处理的这条消息。

## 动态方法解析

对象在收到无法解读的消息后，首先将调用其所属类的以下类方法：

```
+ (BOOL)resolveInstanceMethod:(SEL)selector
```

该方法的参数就是那个未知的选择子，其返回值为Boolean类型，表示这个类是否能新增一个实例方法用以处理此选择子。在继续往下执行转发机制之前，本类有机会新增一个处理此选择子的方法。假如尚未实现的方法不是实例方法而是类方法，那么运行期系统就会调用另外一个方法，该方法与“resolveInstanceMethod:”类似，叫做"resolveClassMethod:"。

使用这种办法的前提是：相关方法的实现代码已经写好，只等着运行的时候动态插在类里面就可以了。此方案常用来实现@dynamic属性（参见第6条），比如说，要访问CoreData框架中NSManagedObjects对象的属性时就可以这么做，因为实现这些属性所需的存取方法在编译器就能确定。
