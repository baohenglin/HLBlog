## 本章内容：

* 学习散列表——最有用的基本数据结构之一。散列表用途广泛，本章将介绍其常见的用途。
* 学习散列表的内部机制:实现、冲突和散列函数。这将帮助你理解如何分析散列表的性能。

假设你在一家杂货店上班。有顾客来买东西时，你得在一个本子中查 找价格。如果本子的内容不是按字母顺序排列的，你可能为查找苹果 (apple)的价格而浏览每一行，这需要很长的时间。此时你使用的是第1章 介绍的简单查找，需要浏览每一行。还记得这需要多长时间吗?O(n)。如 果本子的内容是按字母顺序排列的，可使用二分查找来找出苹果的价格，这需要的时间更短，为O(log n)。其实还有一种方法比二分查找还要快，它查找所需要的时间是O(1)，这就是散列表。

## 散列函数

散列函数是这样的函数，即无论你给它什么数据，它都还你一个数字。如果用专业术语来表达的话，我们会说，散列函数“**将输入映射到数字**”。你可能认为散列 函数输出的数字没什么规律，但其实散列函数必须满足一些要求:

* 它必须是一致的。例如，假设你输入apple时得到的是4，那么每次输入apple时，得到的都 必须为4。如果不是这样，散列表将毫无用处。
* 它应将不同的输入映射到不同的数字。例如，如果一个散列函数不管输入是什么都返回1， 它就不是好的散列函数。最理想的情况是，将不同的输入映射到不同的数字。

散列函数将输入映射为数字，这有何用途呢?

为此，首先创建一个空数组。你将在这个数组中存储商品的价格。下面来将苹果的价格加入到这个数组中。为此，将apple 作为输入交给散列函数。散列函数的输出为3，因此我们将苹果的价格存储到数组的索引3处。下面将牛奶(milk)的价格存储到数组中。为此，将milk作为散列函数的输入。散列函数的输出为0，因此我们将牛奶的价格存储在索引0处。不断地重复这个过程，最终整个数组将填满价格。

现在假设需要知道鳄梨(avocado)的价格。你无需在数组中查找，只需将avocado作为输入 交给散列函数。它将告诉你鳄梨的价格存储在索引4处。果然，你在那里找到了。散列函数准确地指出了价格的存储位置，你根本不用查找!之所以能够这样，具体原因如下：

* 散列函数总是将同样的输入映射到相同的索引。每次你输入avocado，得到的都是同一个 数字。因此，你可首先使用它来确定将鳄梨的价格存储在什么地方，并在以后使用它来 确定鳄梨的价格存储在什么地方。
* 散列函数将不同的输入映射到不同的索引。avocado映射到索引4，milk映射到索引0。每 种商品都映射到数组的不同位置，让你能够将其价格存储到这里。
* 散列函数知道数组有多大，只返回有效的索引。如果数组包含5个元素，散列函数就不会 返回无效索引100。

你结合使用散列函数和数组创建了一种被称为散列表(hash table)的数据结构。散列表是你学习的第一种包含额外逻辑的数据结构。数组和链表都被直接映 射到内存，但散列表更复杂，它使用散列函数来确定元素的存储位置。

在你将学习的复杂数据结构中，散列表可能是最有用的，也被称为散列映射、映射、字典和 关联数组。散列表的速度很快!还记得第2章关于数组和链表的讨论吗?你可以立即获取数组中 的元素，而散列表也使用数组来存储数据，因此其获取元素的速度与数组一样快。

你可能根本不需要自己去实现散列表，任一优秀的语言都提供了散列表实现。Python提供的 散列表实现为字典，你可使用函数dict来创建散列表。

```
book = dict()
# 创建散列表book后，在其中添加一些商品的价格
book["apple"] = 0.67
book["milk"] = 1.49
book["avocado"] = 1.49
print(book)
# 打印结果：{'avocado': 1.49, 'apple': 0.67, 'milk': 1.49}
```

查询鳄梨的价格：

```
print book["avocado"]
```

散列表由键和值组成。在前面的散列表book中，键为商品名，值为商品价格。散列表将键 映射到值。

## 散列表应用案例

散列表用途广泛，本节将介绍几个应用案例。

**应用案例1：将散列表用于查找**

手机都内置了方便的电话簿，其中每个姓名都有对应的电话号码。假设你要创建一个类似这样的电话簿，将姓名映射到电话号码。该电话簿需要提供如下功能。

* 添加联系人及其电话号码。
* 通过输入联系人来获悉其电话号码。

这非常适合使用散列表来实现!在下述情况下，使用散列表是很不错的选择：

* (1)创建映射。
* (2)查找。

创建电话簿非常容易。首先，新建一个散列表:

```
phone_book = dict()
```
此外，Python提供了一种创建散列表的快捷方式——使用一对大括号。与使用dict()等效。

```
phone_book = {}
```

下面在这个电话簿中添加一些联系人的电话号码：

```
phone_book["jenny"] = 110
phone_book["jack"] = 119
```

现在，假设你要查找Jenny的电话号码，为此只需向散列表传入相应的键。

```
print(phone_book["jenny"])
```

散列表被用于大海捞针式的查找。例如，你在访问像 http://adit.io 这样的网站时，计算机必须将adit.io转换为IP地址。无论你访问哪个网站，其网址都必须转换为IP地址。这不是将网址映射到IP地址吗?好像非常适合使用散列表啰!这个过程被称为DNS解析 (DNS resolution)，散列表是提供这种功能的方式之一。

**应用案例2：防止重复**

假设你负责管理一个投票站。显然，每人只能投一票，但如何避免重复投票呢?有人来投票时，你询问他的全名，并将其与已投票者名单进行比对。如果名字在名单中，就说明这个人投过票了，因此将他拒之门外!否则，就将他的姓名加入 到名单中，并让他投票。现在假设有很多人来投过了票，因此名单非常长。

每次有人来投票时，你都得浏览这个长长的名单，以确定他是否投过票。但有一种更好的办 法，那就是使用散列表!为此，首先创建一个散列表，用于记录已投票的人。

```
voted = {}
```

有人来投票时，检查他是否在散列表中。

```
value = voted.get("tom")
```

如果“tom”在散列表中，函数get将返回它;否则返回None。你可使用这个函数检查来投票的人是否投过票!

完整代码如下：

```
voted = {}
def check_voter(name):
    if voted.get(name):
      print("kick them out!")
    else:
      voted[name] = True
      print("let them vote!")
```

如果你将已投票者的姓名存储在列表中，这个函数的速度终将变得非常慢，因为它 必须使用简单查找搜索整个列表。但这里将它们存储在了散列表中，而散列表让你能够迅速知道 来投票的人是否投过票。使用散列表来检查是否重复，速度非常快。

**应用案例3：将散列表用作缓存**

来看最后一个应用案例:缓存。如果你在网站工作，可能听说过进 行缓存是一种不错的做法。下面简要地介绍其中的原理。假设你访问网 站facebook.com。

* (1) 你向Facebook的服务器发出请求。
* (2) 服务器做些处理，生成一个网页并将其发送给你。
* (3) 你获得一个网页。

例如，Facebook的服务器可能搜集你朋友的最近活动，以便向你显示这些信息，这需要几秒 钟的时间。作为用户的你，可能感觉这几秒钟很久，进而可能认为Facebook怎么这么慢!另一方 面，Facebook的服务器必须为数以百万的用户提供服务，每个人的几秒钟累积起来就相当多了。 为服务好所有用户，Facebook的服务器实际上在很努力地工作。有没有办法让Facebook的服务器 少做些工作，从而提高Facebook网站的访问速度呢?

假设你有个侄女，总是没完没了地问你有关星球的问题。火星离地球多远?月球呢?木星 呢?每次你都得在Google搜索，再告诉她答案。这需要几分钟。现在假设她老问你月球离地球多 远，很快你就记住了月球离地球238 900英里。因此不必再去Google搜索，你就可以直接告诉她 答案。这就是缓存的工作原理:网站将数据记住，而不再重新计算。

如果你登录了Facebook，你看到的所有内容都是为你定制的。你每次访问facebook.com，其 服务器都需考虑你感兴趣的是什么内容。但如果你没有登录，看到的将是登录页面。每个人看到 4 的登录页面都相同。Facebook被反复要求做同样的事情:“当我注销时，请向我显示主页。”有鉴 于此，它不让服务器去生成主页，而是将主页存储起来，并在需要时将其直接发送给用户。这就是缓存，具有如下两个优点:

* (1)用户能够更快地看到网页，就像你记住了月球与地球之间的距离时一样。下次你侄女再 9 问你时，你就不用再使用Google搜索，立刻就可以告诉她答案。
* (2)Facebook需要做的工作更少。

缓存是一种常用的加速方式，所有大型网站都使用缓存，而缓存的数据则存储在散列表中!Facebook不仅缓存主页，还缓存About页面、Contact页面、Terms and Conditions页面等众多 其他的页面。因此，它需要将页面URL映射到页面数据。

```
facebook.com/about -> About页面的数据
facebook.com -> 主页的数据
```

当你访问Facebook的页面时，它首先检查散列表中是否存储了该页面。具体代码如下：

```
cache = {}
def get_page(url):
    if cache.get(url):
        #返回缓存的数据
        return  cache[url]
    else:
        data = get_data_from_server(url)
        #先将数据保存到缓存中
        cache[url] = data
        return data
```

仅当URL不在缓存中时，你才让服务器做些处理，并将处理生成的数据存储到缓存中，再返 回它。这样，当下次有人请求该URL时，你就可以直接发送缓存中的数据，而不用再让服务器进 行处理了。

由此散列表适合用于:

* 模拟映射关系；
* 防止重复；
* 缓存/记住数据，以免服务器再通过处理来生成它们。








