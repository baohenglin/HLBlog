# 第1章 温故而知新

本章主要介绍基本的背景知识，包括硬件、操作系统、线程等。

## 1.1 从 Hello World 说起

简单的事物背后往往又蕴含着复杂的机制，如果我们深入思考一个简单的“Hello World”程序，就会发现很多问题看似很简单，但实际上我们并没有一个非常清晰的思路；或者在我们脑海里有着模糊的印象，但真正到某些细节的时候可能又模糊不清了。比如对于C语言编写的Hello World程序：

```
#include <stdio.h>
int main()
{
  printf("Hello world\n");
  retrun 0;
}
```

对于下面这些问题，你的脑子里能够马上反应出一个很清晰又很明确的答案吗？

* 程序为什么要被编译器编译了之后才可以运行？
* 编译器在把C语言程序转换成可以执行的机器码的过程中做了什么，怎么做的？
* 最后编译出来的可执行文件里面是什么？除了机器码还有什么？它们怎么存放的？怎么组织的？
* #include <stdio.h>是什么意思？把stdio.h包含进来意味着什么？C语言库又是什么？它怎么实现的？
* 不同的编译器(Microsoft VC、GCC)和不同的硬件平台（x86、SPARC、MIPS、ARM），以及不同的操作系统（Windows、Linux、UNIX、Solaris），最终编译出来的结果一样吗？为什么？
* Hello World 程序是怎么运行起来的？操作系统是怎么装载它的？它从哪儿开始执行，到哪儿结束？main函数之前发生了什么？main函数结束以后又发生了什么？
* 如果没有操作系统，Hello World 可以运行吗？如果要在一台没有操作系统的机器上运行 Hello World 需要什么？应该怎么实现？
* printf是怎么实现的？它为什么可以有不定数量的参数？为什么它能够在终端上输出字符串？
* Hello World程序在运行时，它在内存中是什么样子的？

对于以上的这些问题，如果你发现对其中一些问题并不是很了解，甚至从来没有想到过一个 Hello World还能引出这么多值得思考的问题，而你又想了解它们，那么恭喜你，这本书就是为你准备的。随着各个章节的逐步展开，我们会从最基本的编译、静态链接到操作系统如何装载程序、动态链接及运行库和标准库的实现，甚至一些操作系统的机制，力争深入浅出地将这些问题层层剥开，最终使得这些程序运行背后的机制形成一个非常清晰而流畅的脉络。
