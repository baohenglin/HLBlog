# 第 18 条 尽量使用不可变对象

**要点**：

* 尽量创建不可变的对象。
* 若某属性仅可于对象内部修改，则在“class-continuation分类”中将其由 readonly 属性扩展为 readwrite 属性。
* 不要把可变的 collection 作为属性公开，而应提供相关的方法，以此修改对象中的可变 collection。

设计类的时候，应充分运用属性封装数据（参见第6条）。而在使用属性时，则可将其声明为“只读”(read-only)。默认情况下，属性是“既可读又可写的”（read-write），这样设计出来的类都是“可变的”（mutable）。不过，一般情况下我们要建模的数据未必需要改变。比方说，某数据所表示的对象源自一项只读的网络服务（web service），里面可能包含一系列需要显示在地图上的相关点，像这种对象就没必要改变其内容。即使修改了，新数据也不会推送回服务器。正如第8条所述，如果把可变对象（mutable object）放入 collection 之后又修改其内容，那么很容易就会破坏 set 的内部数据结构，使其失去固有的语义。因此，笔者建议大家尽量减少对象中的可变内容。

具体到编程实践中，则应该尽量把对外公布出来的属性设为只读，而且只在确有必要时才将属性对外公布。例如，要编写一个类来处理地图上的景点，这些点的数据通过某个网络服务来获取。一开始写出来的代码也许是这样：

```
#import <Foundation/Foundation.h>
@interface EOCPointOfInterest : NSObject

@property (nonatomic, copy) NSString *identifier;
@property (nonatomic, copy) NSString *title;
@property (nonatomic, assign) float latitude;
@property (nonatomic, assign) float longitude;

- (id)initWithIdentifier: (NSString *)identifier 
                    title:(NSString*)title
                 latitude:(float)latitude
                longitude:(float)longitude;
@end
```

对象中的值都经由网络服务获取，在与网络服务通信的过程中，以 identifier 来指代相关的景点。用网络服务所提供的数据创建好某个点之后，就无须改动其值了。如果用其他编程语言来写，则可能会通过响应的机制创建出私有的实例变量，这些变量只有 get 存取方法，没有 set 存取方法。然而使用 Objective-C 编程时则会简单很多，根本无须考虑私有变量。为了将 EOCPointOfInterest 做成不可变的类，需要把所有属性都声明为 readonly：

```
#import <Foundation/Foundation.h>
@interface EOCPointOfInterest : NSObject

@property (nonatomic, copy, readonly) NSString *identifier;
@property (nonatomic, copy, readonly) NSString *title;
@property (nonatomic, assign, readonly) float latitude;
@property (nonatomic, assign, readonly) float longitude;

- (id)initWithIdentifier: (NSString *)identifier 
                    title:(NSString*)title
                 latitude:(float)latitude
                longitude:(float)longitude;
@end
```

如果有人试着改变属性值，那么编译的时候就会报错。对象中的属性值可以读出，但是无法写入，这就能保证 EOCPointOfInterest 中的各个数据之间总是相互协调的。于是，开发者在使用对象时就能肯定其底层数据不会改变。因此，对象本身的数据结构也就不可能出现不一致的现象。比如说，在将 EOCPointOfInterest 对象显示到地图视图上时，这些点的底层经纬度数据不会变动。








