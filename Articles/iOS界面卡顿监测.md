## 造成卡顿的几种原因：

* 复杂UI、图文混排的绘制量过大；
* 在主线程上做网络同步请求；
* 在主线程做大量的IO操作；
* 运算量过大，CPU持续高占用；
* 死锁和主子线程抢锁。

那么如何监控卡顿呢？是要监控FPS吗？监控FPS来判断卡顿是否准确呢？

FPS是一秒显示的帧数，也就是一秒内画面变化的数量。如果按照动画片来说，动画片的FPS就是24，是达不到60满帧的。24帧虽然没有60帧时流畅，但是也已经是连贯的了，所以并不能说24帧时就算卡顿了。

由此可见，简单地通过监测FPS是很难确定是否会出现卡顿问题，所以不推荐通过监视FPS来监控卡顿的方案。

我们可以**通过监听RunLoop的状态来监控卡顿**。监控卡顿其实就是要找出主线程都做了哪些事情。众所周知，线程的消息事件是依赖于NSRunLoop的，所以从NSRunLoop入手，就可以知道主线程上都调用了哪些方法。我们通过监听NSRunLoop的状态，就能够发现调用方法是否执行时间过长，从而判断是否出现了卡顿现象。

## RunLoop原理

RunLoop这个对象在iOS里由CFRunLoop实现。简单来说，RunLoop是用来监听输入源，进行调度处理的。输入源可以是输入设备、网络、周期性或延迟时间、异步回调。RunLoop会接收两种类型的输入源：一种是来自另一个线程或者来自不同应用的异步消息；另一种是来自预定时间或者重复间隔的同步事件。

RunLoop的作用是当有事件要去处理时保持线程忙，当没有事件要处理时让线程进入休眠。所以，了解**RunLoop原理不仅可以运用到监控卡顿上，还可以提高用户的交互体验。通过将那些繁重而不紧急会大量占用CPU的任务（比如图片加载），放到空闲的RunLoop模式里执行，就可以避免在UITrackingRunLoopMode这个RunLoop模式里执行。**UITrackingRunLoopMode是用户进行滑动操作时切换到的RunLoop模式，避免在这个RunLoop模式执行繁重的CPU任务，可以提高用户体验。





























**参考链接**

* [iOS实时卡顿监控](http://www.tanhao.me/code/151113.html/)
* [微信iOS卡顿监控系统](https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=207890859&idx=1&sn=e98dd604cdb854e7a5808d2072c29162&scene=4)
* [卡顿监测-FPS监测](https://juejin.im/entry/5c8cc988e51d4552775db9d2)
