# 第一章 算法简介

算法是一组完成任务的指令。任何代码片段都可视为算法。

## 1.1 二分查找

二分查找是一种算法，其查找的列表必须是一个**有序**的元素列表。使用二分查找时，每次都排除一半的元素。一般而言，对于包含n个元素的列表，用二分查
找最多需要log<sub>2</sub>n步，而简单查找最多需要n步。

仅当列表是有序的时候，二分查找才管用。例如，电话簿中的名字是按字母顺序排列的， 因此可以使用二分查找来查找名字。

```
def binary_search(list, item):
    low = 0
    high = len(list)-1
    #只要范围没有缩小到只包含一个元素，就继续循环
    while low <= high:
        mid = (int)((low + high) / 2)
        guess = list[mid]
        if guess == item:
            return mid
        if guess > item:
            high = mid - 1
        else:
            low = mid + 1
    #注意缩进的格数，否则程序出错。
    return None


my_list = [1, 3, 5, 7, 9, 11] 
print(binary_search(my_list, 3))
```

## 1.2 运行时间

每次介绍算法时，我都将讨论其运行时间。一般而言，应选择效率最高的算 法，以最大限度地减少运行时间或占用空间。

回到前面的二分查找。使用它可节省多少时间呢?简单查找逐个地检查数 字，如果列表包含100个数字，最多需要猜100次。如果列表包含40亿个数字，最 多需要猜40亿次。换言之，最多需要猜测的次数与列表长度相同，这被称为线性 时间(linear time)。

二分查找则不同。如果列表包含100个元素，最多要猜7次;如果列表包含40亿个数字，最多 需猜32次。厉害吧?二分查找的运行时间为对数时间(或log时间)。

## 1.3 大O表示法

大O表示法是一种特殊的表示法，指出了算法的速度有多快。



