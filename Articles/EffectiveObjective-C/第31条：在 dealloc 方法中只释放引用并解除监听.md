# 第 31 条：在 dealloc 方法中只释放引用并解除监听

对象在经历其生命期后，最终会为系统所回收，这时就要执行 dealloc 方法了。在每个对象的生命期内，此方法**仅执行一次**，也就是当保留计数降为 0 的时候。然而具体何时执行，则无法保证。也可以理解成：我们能够通过人工观察保留操作与释放操作的位置，来预计此方法何时即将执行。但实际上，程序库会以开发者觉察不到的方式操作对象，从而使回收对象的真正时机和预期的不同。**开发者勿手动调用 dealloc 方法**。运行期系统会在适当的时候调用它。而且，一旦调用过 dealloc 之后，对象就不再有效了，后续方法调用均是无效的。

那么，应该在 dealloc 方法中做些什么呢？主要是**释放所拥有的引用**（用途1），也就是**把所有 Objective-C 对象都释放掉**，ARC 会通过自动生成的 .cxx_destruct 方法（参见第 30 条），在 dealloc 中为你自动添加这些释放代码。**对象所拥有的其他非 Objective-C 对象也要释放**（用途2）。比如 CoreFoundation 对象就必须手动释放，因为它们是由纯 C 的 API 所生成的。

在 dealloc 方法中，通常还要做一件事，那就是把原来配置过的观测行为（observation behavior）都清理掉（用途3：**注销通知**）。如果用 NSNotificationCenter 给此对象订阅（register）过某种通知，那么一般应该在这里注销（unregister），这样的话，通知系统就不再把通知发给回收后的对象了，若是还向其发送通知，则必然会令应用程序崩溃。

dealloc 方法可以这样来写：

```
- (void)dealloc {
  CFRelease(coreFoundationObject); //释放对象所拥有的其他非 Objective-C 对象
  [[NSNotificationCenter defaultCenter] removeObserver:self]; //注销通知
}
```

需要注意的是，**如果手动管理引用计数而不使用 ARC 的话，那么最后还需要调用“[super dealloc]”。ARC会自动执行此操作，这再次表明其比手动管理更简单、更安全**。若选择手动管理，则还要将当前对象所拥有的全部 Objective-C 对象逐个释放。

虽说应该于 dealloc 中释放引用，**但是开销较大或系统内稀缺的资源则不在此列。像是文件描述符（file descriptor）、套接字（socket）、大块内存等，都属于这种资源**。不能指望 dealloc 方法必定会在某个特定的时机调用，因为有一些无法预料的东西可能也持有此对象。在这种情况下，如果非要等到系统调用 dealloc 方法时才释放，那么保留这些稀缺资源的时间就有些过长了，这么做不合适。**通常的做法是，实现另外一个方法，当应用程序用完资源对象后，就调用此方法**。这样一来，资源对象的生命周期就变得更为明确了。

比如说，如果某对象管理着连接服务器所用的套接字，那么也许就需要这种“清理方法”（cleanup method）。此对象可能要通过套接字连接到数据库。对于对象所属的类，其接口可以这样写：

```
#import <Foundation/Foundation.h>

@interface EOCServerConnection : NSObject
- (void)open: (NSString *)address;
- (void)close;
@end
```

该类与开发者之间的约定是：想打开连接，就调用 open 方法；连接使用完毕，就调用 close 方法。**“关闭”操作必须在系统把连接对象回收之前调用**，否则就是编程错误（programmer error），这与通过“保留”及“释放”操作来平衡引用计数是类似的。
