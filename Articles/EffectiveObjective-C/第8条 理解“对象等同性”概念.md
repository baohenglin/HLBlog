## 第8条 对象等同性

### 要点：

* 若想检测对象的等同性，请提供“isEqual:”与hash 方法。
* 相同的对象必须具有相同的哈希码，但是两个哈希码相同的对象却未必相同。
* 不要盲目地逐个检测每条属性，而是应该依照具体需求来制定检测方案。
* 编写 hash 方法时，应该使用计算速度快而且哈希码碰撞机率低的算法。

根据“等同性”（equality）来比较对象是一个非常有用的功能。不过，按照 == 操作符比较出来的结果未必是我们想要的，**因为“==”该操作比较的是两个指针本身，而不是其所指的对象。应该使用 NSObject 协议中声明的“isEqual:”方法来判断两个对象的等同性**。一般来说，两个类型不同的对象总是不相等的（unequal）。某些对象提供了特殊的“等同性判定方法”（equality-checking method），如果已经知道两个受测对象都属于同一个类，那么就可以使用这种方法。

以下述代码为例：

```
NSString *foo = @"Badger 123";
NSString *bar = [NSString stringWithFormat:@"Badger %i",123];
BOOL equalA = (foo == bar); //equalA = NO
BOOL equalB = [foo isEqual:bar];  //equalB = YES
BOOL equalC = [foo isEqualToString:bar];  //equalC = YES
```

我们可以看到"=="与等同性判断方法之间的差别。NSString 类实现了一个自己独有的等同性判断方法，名叫“isEqualToString:”。传递给该方法的对象必须是 NSString，否则结果未定义（undefined）。**调用“isEqualToString:”方法比调用“isEqual:”方法快，后者还要执行额外的步骤，因为它不知道受测对象的类型**。

NSObject 协议中有两个用于判断等同性的关键方法：

```
- (BOOL)isEqual:(id)object;
- (NSUInteger)hash;
```

NSObject类对这两个方法的默认实现是：**当且仅当其“指针值”（pointer value）完全相等时，这两个对象才相等。若想在自定义的对象中正确覆写这些方法，就必须先理解其约定（contract）。如果“isEqual:”方法判定两个对象相等，那么其hash方法也必须返回同一个值。但是，如果两个对象的hash方法返回同一个值，那么“isEqual:”方法未必会认为两者相等**。

比如有下面这个类：

```
@interface EOCPerson : NSObject
@property (nonatomic, copy) NSString *firstName;
@property (nonatomic, copy) NSString *lastName;
@property (nonatomic, assign) NSInteger age;
```

我们认为，如果两个 EOCPerson 的所有字段均相等，那么这两个对象就相等。于是“isEqual:”方法可以写成：

```
- (BOOL)isEqual:(id)object {
    if(self == object) return YES;
    if([self class] != [object class]) return NO;
    EOCPerson *otherPerson = (EOCPerson *)object;
    if(![_firstName isEqualToString:otherPerson.firstName])
        return NO;
    if(![_lastName isEqualToString:otherPerson.lastName])
        return NO;
    if(_age != otherPerson.age)
        return NO;
    return YES;
}
```

首先，直接判断两个指针是否相等。若相等，则其均指向同一对象，所以受测的对象也必定相等。接下来，比较两对象所属的类。若不属于同一个类，则两对象不相等。EOCPerson对象当然不可能与 EOCDog对象相等。不过，有时我们可能认为：一个 EOCPerson 实例可以与其子类（比如 EOCSmithPerson）实例相等。在继承体系中判断等同性时，经常遭遇此类问题。所以实现“isEqual:”方法时要考虑到这种情况。最后，检测每个属性是否相等。只要其中有不相等的属性，就判定两对象不等，否则两对象相等。

接下来该实现 hash 方法了。根据等同性约定：若两对象相等，则其哈希码（hash）也相等，但是两个哈希码相同的对象却未必相等。这是能否正确覆写“isEqual:”方法的关键所在。下面这种写法完全可行：

```
- (NSUInteger)hash {
    return 1337;
}
```

不过若是这么写的话，在 collection 中使用这种对象将产生性能问题，因为 collection 在检索哈希表（hash table）时，会用对象的哈希码做索引。假如某个 collection 是用 set 实现的，那么 set 可能会根据哈希码把对象分装到不同的数组中。

在向 set 中添加新对象时，要根据其哈希码找到与之相关的那个数组，依次检查其中各个元素，看数组中已有的对象是否和将要添加的新对象相等。如果相等，那就说明要添加的对象已经在 set 里面了。由此可知，如果令每个对象都返回相同的哈希码，那么在set中已有 1000000个对象的情况下，若是继续向其中添加对象，则需要将这 1000000个对象全部扫描一遍。

hash 方法也可以这样实现：

```
- (NSUInteger)hash {
    NSString *stringToHash = [NSString stringWithFormat:@"%@:%@:%i",_firstName, _lastName, _age];
    return [stringToHash hash];
}
```

这次所用的办法是将 NSString 对象中的属性都塞入另一个字符串中，然后令hash 方法返回该字符串的哈希码。这么做符合约定，因为两个相等的 EOCPerson 对象总会返回相同的哈希码。但是这样做还需负担创建字符串的开销，所以比返回单一值要慢。把这种对象添加到 collection 中时，也会产生性能问题，因为要想添加，必须先计算其哈希码。

再来看最后一种计算哈希码的办法：

```
- (NSUInteger)hash {
    NSUInteger firstNameHash = [_firstName hash];
    NSUInteger lastNameHash = [_lastName hash];
    NSUInteger ageHash = _age;
    return firstNameHash ^ lastNameHash ^ ageHash;
}
```

这种做法既能保持高效率，又能使生成的哈希码至少位于一定范围内，而不会过于频繁地重复。当然，此算法生成的哈希码还是会碰撞（collision），不过至少可以保证哈希码有多种可能的取值。编写 hash 方法时，应该用当前的对象做做实验，以便在减少碰撞频度与降低运算复杂程度之间取舍。

### 特定类所具有的等同性判断方法

除了刚才提到的 NSString 之外，NSArray与NSDictionary 类也具有特殊的等同性判定方法，前者名为“isEqualToArray:”，后者名为“isEqualToDictionary:”。如果和其相比较的对象不是数组或字典，那么这两个方法会各自抛出异常。由于 Objective-C在编译器不做强类型检查（strong type checking），这样容易不小心传入类型错误的对象，因此开发者应该保证所传对象的类型是正确的。

如果经常需要判断等同性，那么可能会自己来创建等同性判定方法，因为无须检测参数类型，所以能大大提升检测速度。自己来编写判定方法的另一个原因是，我们想令代码看上去更美观、更易读，此动机与 NSString类“isEualToString:”方法的创建缘由相似，纯粹为了装点门面。使用此种判定方法编出来的代码更容易读懂，而且不用再检查两个受测对象的类型了。


















