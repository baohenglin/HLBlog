# 第3章 递归

递归只是让解决方案更清晰，并 没有性能上的优势。实际上，在有些情况下，使用循环的性能更好。我很喜欢Leigh Caldwell在Stack Overflow上说的一句话:“如果使用循环，程序的性能可能更高;如果使用递归，程序可能更容易理解。如何选择要看什么对你来说更重要。”

**基线条件和递归条件**

由于递归函数调用自己，因此编写这样的函数时很容易出错，进而导致无限循环。例如，假设你要编写一个像下面这样倒计时的函数。

为此，你可以用递归的方式编写，如下所示。

```
def countdown(i):
    print(i)
    countdown(i-1)
```

如果你运行上述代码，将发现一个问题:这个函数运行起来没完没了!

编写递归函数时，必须告诉它何时停止递归。正因为如此，每个递归函数都有两部分:基线 条件(base case)和递归条件(recursive case)。递归条件指的是函数调用自己，而基线条件则 指的是函数不再调用自己，从而避免形成无限循环。

我们来给函数countdown添加基线条件。

```
def countdown(i):
    print(i)
    #基线条件
    if i <= 0:
        retrun
    #递归条件
    else:
        countdown(i-1)
```

**栈**

栈是一种简单的数据结构。栈又称为堆栈。它是一种运算受限的线性表。限定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。

它按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。栈具有记忆作用，对栈的插入与删除操作中，不需要改变栈底指针。

**调用栈**

计算机在内部使用被称为调用栈的栈。我们来看看计算机是如何使用调用栈的。下面是一个 简单的函数。

```
def greet(name):
print ("hello, " + name + "!")
greet2(name)
print ("getting ready to say bye...") 
bye()
```

这个函数问候用户，再调用另外两个函数。这两个函数的代码如下：

```
def greet2(name):
print ("how are you, " + name + "?")

def bye():
print ("ok bye!")
```

下面详细介绍调用函数时发生的情况：

【注意】在Python中，print是一个函数，但出于简化考虑，这里假设它不是函数。

假设你调用greet("maggie")，计算机将首先为该函数调用分配一块内存。我们来使用这些内存。变量name被设置为maggie，这需要存储到内存中。每当你调用函数时，计算机都像这样将函数调用涉及的所有变量的值存储到内存中。接下来， 你打印hello, maggie!，再调用greet2("maggie")。同样，计算机也为这个函数调用分配一块内存。计算机使用一个栈来表示这些内存块，其中第二个内存块位于第一个内存块上面。你打印 how are you, maggie?，然后从函数调用返回。此时，栈顶的内存块被弹出。现在，栈顶的内存块是函数greet的，这意味着你返回到了函数greet。当你调用函数greet2 时，函数greet只执行了一部分。这是本节的一个重要概念:调用另一个函数时，当前函数暂停 并处于未完成状态。该函数的所有变量的值都还在内存中。执行完函数greet2后，你回到函数 greet，并从离开的地方开始接着往下执行:首先打印getting ready to say bye...，再调用 函数bye。在栈顶添加了函数bye的内存块。然后，你打印ok bye!，并从这个函数返回。现在你又回到了函数greet。由于没有别的事情要做，你就从函数greet返回。这个栈用于存储多个函数的变量，被称为调用栈。

**递归调用栈**

递归函数也使用调用栈!来看看递归函数factorial的调用栈。factorial(5)写作5!，其定义如下:5! = 5 * 4 * 3 * 2 * 1。同理，factorial(3)为3 * 2 * 1。下面是计算阶乘的递归函数：

```
def fact(x): 
    if x == 1: 
        return 1
    else:
        return x * fact(x-1)
```

下面来详细分析调用fact(3)时调用栈是如何变化的。别忘了，栈顶的方框指出了当前执行 到了什么地方。

![Fact调用栈第1次调用.png](https://upload-images.jianshu.io/upload_images/4164292-bbef99255aa463c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![Fact调用栈第2次调用.png](https://upload-images.jianshu.io/upload_images/4164292-e2dc395c3aa1d1ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![Fact调用栈返回值.png](https://upload-images.jianshu.io/upload_images/4164292-f0cf42cd019e04d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)











