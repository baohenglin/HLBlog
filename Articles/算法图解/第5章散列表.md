## 本章内容：

* 学习散列表——最有用的基本数据结构之一。散列表用途广泛，本章将介绍其常见的用途。
* 学习散列表的内部机制:实现、冲突和散列函数。这将帮助你理解如何分析散列表的性能。

假设你在一家杂货店上班。有顾客来买东西时，你得在一个本子中查 找价格。如果本子的内容不是按字母顺序排列的，你可能为查找苹果 (apple)的价格而浏览每一行，这需要很长的时间。此时你使用的是第1章 介绍的简单查找，需要浏览每一行。还记得这需要多长时间吗?O(n)。如 果本子的内容是按字母顺序排列的，可使用二分查找来找出苹果的价格，这需要的时间更短，为O(log n)。其实还有一种方法比二分查找还要快，它查找所需要的时间是O(1)，这就是散列表。

## 散列函数

散列函数是这样的函数，即无论你给它什么数据，它都还你一个数字。如果用专业术语来表达的话，我们会说，散列函数“**将输入映射到数字**”。你可能认为散列 函数输出的数字没什么规律，但其实散列函数必须满足一些要求:

* 它必须是一致的。例如，假设你输入apple时得到的是4，那么每次输入apple时，得到的都 必须为4。如果不是这样，散列表将毫无用处。
* 它应将不同的输入映射到不同的数字。例如，如果一个散列函数不管输入是什么都返回1， 它就不是好的散列函数。最理想的情况是，将不同的输入映射到不同的数字。

散列函数将输入映射为数字，这有何用途呢?

为此，首先创建一个空数组。你将在这个数组中存储商品的价格。下面来将苹果的价格加入到这个数组中。为此，将apple 作为输入交给散列函数。散列函数的输出为3，因此我们将苹果的价格存储到数组的索引3处。下面将牛奶(milk)的价格存储到数组中。为此，将milk作为散列函数的输入。散列函数的输出为0，因此我们将牛奶的价格存储在索引0处。不断地重复这个过程，最终整个数组将填满价格。

现在假设需要知道鳄梨(avocado)的价格。你无需在数组中查找，只需将avocado作为输入 交给散列函数。它将告诉你鳄梨的价格存储在索引4处。果然，你在那里找到了。散列函数准确地指出了价格的存储位置，你根本不用查找!之所以能够这样，具体原因如下：

* 散列函数总是将同样的输入映射到相同的索引。每次你输入avocado，得到的都是同一个 数字。因此，你可首先使用它来确定将鳄梨的价格存储在什么地方，并在以后使用它来 确定鳄梨的价格存储在什么地方。
* 散列函数将不同的输入映射到不同的索引。avocado映射到索引4，milk映射到索引0。每 种商品都映射到数组的不同位置，让你能够将其价格存储到这里。
* 散列函数知道数组有多大，只返回有效的索引。如果数组包含5个元素，散列函数就不会 返回无效索引100。

你结合使用散列函数和数组创建了一种被称为散列表(hash table)的数据结构。散列表是你学习的第一种包含额外逻辑的数据结构。数组和链表都被直接映 射到内存，但散列表更复杂，它使用散列函数来确定元素的存储位置。

在你将学习的复杂数据结构中，散列表可能是最有用的，也被称为散列映射、映射、字典和 关联数组。散列表的速度很快!还记得第2章关于数组和链表的讨论吗?你可以立即获取数组中 的元素，而散列表也使用数组来存储数据，因此其获取元素的速度与数组一样快。

你可能根本不需要自己去实现散列表，任一优秀的语言都提供了散列表实现。Python提供的 散列表实现为字典，你可使用函数dict来创建散列表。

```
book = dict()
# 创建散列表book后，在其中添加一些商品的价格
book["apple"] = 0.67
book["milk"] = 1.49
book["avocado"] = 1.49
print(book)
# 打印结果：{'avocado': 1.49, 'apple': 0.67, 'milk': 1.49}
```

查询鳄梨的价格：

```
print book["avocado"]
```

散列表由键和值组成。在前面的散列表book中，键为商品名，值为商品价格。散列表将键 映射到值。

## 散列表应用案例

散列表用途广泛，本节将介绍几个应用案例。

**应用案例1：将散列表用于查找**

手机都内置了方便的电话簿，其中每个姓名都有对应的电话号码。假设你要创建一个类似这样的电话簿，将姓名映射到电话号码。该电话簿需要提供如下功能。

* 添加联系人及其电话号码。
* 通过输入联系人来获悉其电话号码。

这非常适合使用散列表来实现!在下述情况下，使用散列表是很不错的选择：

* (1)创建映射。
* (2)查找。

创建电话簿非常容易。首先，新建一个散列表:

```
phone_book = dict()
```
此外，Python提供了一种创建散列表的快捷方式——使用一对大括号。与使用dict()等效。

```
phone_book = {}
```

下面在这个电话簿中添加一些联系人的电话号码：

```
phone_book["jenny"] = 110
phone_book["jack"] = 119
```

现在，假设你要查找Jenny的电话号码，为此只需向散列表传入相应的键。

```
print(phone_book["jenny"])
```

散列表被用于大海捞针式的查找。例如，你在访问像 http://adit.io 这样的网站时，计算机必须将adit.io转换为IP地址。无论你访问哪个网站，其网址都必须转换为IP地址。这不是将网址映射到IP地址吗?好像非常适合使用散列表啰!这个过程被称为DNS解析 (DNS resolution)，散列表是提供这种功能的方式之一。

**应用案例2：防止重复**

假设你负责管理一个投票站。显然，每人只能投一票，但如何避免重复投票呢?有人来投票时，你询问他的全名，并将其与已投票者名单进行比对。如果名字在名单中，就说明这个人投过票了，因此将他拒之门外!否则，就将他的姓名加入 到名单中，并让他投票。现在假设有很多人来投过了票，因此名单非常长。

每次有人来投票时，你都得浏览这个长长的名单，以确定他是否投过票。但有一种更好的办 法，那就是使用散列表!为此，首先创建一个散列表，用于记录已投票的人。

```
voted = {}
```

有人来投票时，检查他是否在散列表中。

```
value = voted.get("tom")
```

如果“tom”在散列表中，函数get将返回它;否则返回None。你可使用这个函数检查来投票的人是否投过票!

完整代码如下：

```
voted = {}
def check_voter(name):
    if voted.get(name):
      print("kick them out!")
    else:
      voted[name] = True
      print("let them vote!")
```

如果你将已投票者的姓名存储在列表中，这个函数的速度终将变得非常慢，因为它 必须使用简单查找搜索整个列表。但这里将它们存储在了散列表中，而散列表让你能够迅速知道 来投票的人是否投过票。使用散列表来检查是否重复，速度非常快。

**应用案例3：将散列表用作缓存**

来看最后一个应用案例:缓存。如果你在网站工作，可能听说过进 行缓存是一种不错的做法。下面简要地介绍其中的原理。假设你访问网 站facebook.com。

* (1) 你向Facebook的服务器发出请求。
* (2) 服务器做些处理，生成一个网页并将其发送给你。
* (3) 你获得一个网页。

例如，Facebook的服务器可能搜集你朋友的最近活动，以便向你显示这些信息，这需要几秒 钟的时间。作为用户的你，可能感觉这几秒钟很久，进而可能认为Facebook怎么这么慢!另一方 面，Facebook的服务器必须为数以百万的用户提供服务，每个人的几秒钟累积起来就相当多了。 为服务好所有用户，Facebook的服务器实际上在很努力地工作。有没有办法让Facebook的服务器 少做些工作，从而提高Facebook网站的访问速度呢?

假设你有个侄女，总是没完没了地问你有关星球的问题。火星离地球多远?月球呢?木星 呢?每次你都得在Google搜索，再告诉她答案。这需要几分钟。现在假设她老问你月球离地球多 远，很快你就记住了月球离地球238 900英里。因此不必再去Google搜索，你就可以直接告诉她 答案。这就是缓存的工作原理:网站将数据记住，而不再重新计算。

如果你登录了Facebook，你看到的所有内容都是为你定制的。你每次访问facebook.com，其 服务器都需考虑你感兴趣的是什么内容。但如果你没有登录，看到的将是登录页面。每个人看到 4 的登录页面都相同。Facebook被反复要求做同样的事情:“当我注销时，请向我显示主页。”有鉴 于此，它不让服务器去生成主页，而是将主页存储起来，并在需要时将其直接发送给用户。这就是缓存，具有如下两个优点:

* (1)用户能够更快地看到网页，就像你记住了月球与地球之间的距离时一样。下次你侄女再 9 问你时，你就不用再使用Google搜索，立刻就可以告诉她答案。
* (2)Facebook需要做的工作更少。

缓存是一种常用的加速方式，所有大型网站都使用缓存，而缓存的数据则存储在散列表中!Facebook不仅缓存主页，还缓存About页面、Contact页面、Terms and Conditions页面等众多 其他的页面。因此，它需要将页面URL映射到页面数据。

```
facebook.com/about -> About页面的数据
facebook.com -> 主页的数据
```

当你访问Facebook的页面时，它首先检查散列表中是否存储了该页面。具体代码如下：

```
cache = {}
def get_page(url):
    if cache.get(url):
        #返回缓存的数据
        return  cache[url]
    else:
        data = get_data_from_server(url)
        #先将数据保存到缓存中
        cache[url] = data
        return data
```

仅当URL不在缓存中时，你才让服务器做些处理，并将处理生成的数据存储到缓存中，再返 回它。这样，当下次有人请求该URL时，你就可以直接发送缓存中的数据，而不用再让服务器进 行处理了。

由此散列表适合用于:

* 模拟映射关系；
* 防止重复；
* 缓存/记住数据，以免服务器再通过处理来生成它们。


## 散列表冲突

前面说过，大多数语言都提供了散列表实现，你不用知道如何实现它们。有鉴于此，我就不 再过多地讨论散列表的内部原理，但你依然需要考虑性能!要明白散列表的性能，你得先搞清楚 什么是冲突。本节和下一节将分别介绍冲突和性能。

首先，我撒了一个善意的谎。我之前告诉你的是，散列函数总是将不同的键映射到数组的不同位置。实际上，几乎不可能编写出这样的散列函数。我们来看一个简单的示例。假设你有一个数组， 它包含26个位置。而你使用的散列函数非常简单，它按字母表顺序分配数组的位置。你可能已经看出了问题。如果你要将苹果的价格存储到散列表中，分配给你的是第一个位置。接下来，你要将香蕉的价格存储到散列表中，分配给你的是第二个位置。一切顺利!但现在你要将鳄梨的价格存储到散列表中，分配给你的又是第一个位置。

不好，这个位置已经存储了苹果的价格!怎么办?这种情况被称为冲突(collision):给两 个键分配的位置相同。这是个问题。如果你将鳄梨的价格存储到这个位置，将覆盖苹果的价格， 以后再查询苹果的价格时，得到的将是鳄梨的价格!冲突很糟糕，必须要避免。处理冲突的方式 很多，最简单的办法如下:**如果两个键映射到了同一个位置，就在这个位置存储一个链表**。

![散列表冲突解决方法示意图.png](https://upload-images.jianshu.io/upload_images/4164292-57854d265124c2af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

在这个例子中，apple和avocado映射到了同一个位置，因此在这个位置存储一个链表。在需 要查询香蕉的价格时，速度依然很快。但在需要查询苹果的价格时，速度要慢些:你必须在相应 的链表中找到apple。如果这个链表很短，也没什么大不了——只需搜索三四个元素。

![散列表冲突极端情况.png](https://upload-images.jianshu.io/upload_images/4164292-227f9c9d7600e866.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

但是，假设 你工作的杂货店只销售名称以字母A打头的商品。除第一个位置外，整个散列表都是空的，而第一个位置包含一个很长的列表!换言之， 这个散列表中的所有元素都在这个链表中，这与一开始就将所有元素存储到一个链表中一样糟 糕:散列表的速度会很慢。

这里的经验教训有两个：

* 散列函数很重要。前面的散列函数将所有的键都映射到一个位置，而最理想的情况是， 散列函数将键均匀地映射到散列表的不同位置。
* 如果散列表存储的链表很长，散列表的速度将急剧下降。然而，如果使用的散列函数很好，这些链表就不会很长!

散列函数很重要，好的散列函数很少导致冲突。那么，如何选择好的散列函数呢?这将在下一节介绍!

## 性能

本章开头是假设你在杂货店工作。你想打造一个让你能够迅速获悉商品价格的工具，而散列表的速度确实很快。

在平均情况下，散列表执行各种操作(查找、插入、删除)的时间都为O(1)。O(1)被称 为常量时间。你以前没有见过常量时间，它并不意味着马上，而是说 4 不管散列表多大，所需的时间都相同。例如，你知道的，简单查找的运行时间为线性时间。二分查找的速度更快，所需时间为对数时间。

在散列表中查找所花费的时间为常量时间。这意味着无论散列表包含一个元素还是10亿个元素，从其中获取数 据所需的时间都相同。实际上，你以前见过常量时间——从数组中获取一个元素所需的时间就是 固定的:不管数组多大，从中获取一个元素所需的时间都是相同的。在平均情况下，散列表的速 度确实很快。

在最糟情况下，散列表所有操作的运行时间都为O(n)——线性时间，这真的很慢。我们来将 散列表同数组和链表比较一下。

![时间复杂度对比表.png](https://upload-images.jianshu.io/upload_images/4164292-54fd0976dbb1398e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

在平均情况下，散列表的查找(获取给定索引处的值)速度与数组一样快，而插入和删除速 度与链表一样快，因此它兼具两者的优点!但在最糟情况下，散列表的各种操作的速度都很慢。 因此，在使用散列表时，避开最糟情况至关重要。为此，需要避免冲突。而要避免冲突，需要有:

* 较低的填装因子;
* 良好的散列函数。

## 填装因子

散列表的填装因子很容易计算。散列表填装因子 = 散列表包含的元素数 / 位置总数。

散列表使用数组来存储数据，因此你需要计算数组中被占用的位置数。填装因子量度的是散列表中有多少位置是空的。假设要在散列表中存储100种商品的价格，而散列表包含100个位置。那么在最佳情况下，每个商品都将有自己的位置。这个散列表的填装因子为1。填装因子大于1意味着商品数量超过了数组的位置数。一旦填装因子开始增大，你就需要在散列表中添加位置，这被称为调整长度(resizing)。你就需要调整它的长度。为此，你首先创建一个更长的新数组:通常将数组增长一倍。接下来，你需要使用函数hash将所有的元素都插入到这个新的散列表中。

填装因子越低，发生冲突的可能性越小，散列表的性能越高。一个不错的经验规则是:一旦填装因子大于0.7，就调整散列表的长度。

你可能在想，调整散列表长度的工作需要很长时间!你说得没错，调整长度的开销很大，因 此你不会希望频繁地这样做。但平均而言，即便考虑到调整长度所需的时间，散列表操作所需的 时间也为O(1)。










