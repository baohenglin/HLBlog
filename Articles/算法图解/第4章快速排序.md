# 第4章 快速排序

快速排序——一种常用的优雅的排序算法。快速排序使用分而治之的策略。我们将探索分而治之(divide and conquer，D&C)——一种著名的递归式问题解决方法。快速排序是一种排序算法，速 度比第2章介绍的选择排序快得多，实属优雅代码的典范。

## 4.1 分而治之

D&C并不那么容易掌握，我将通过三个示例来介绍。首先， 介绍一个直观的示例;然后，介绍一个代码示例，它不那么好看， 但可能更容易理解;最后，详细介绍快速排序——一种使用D&C的排序算法。

假设你是农场主，有一小块土地。你要将这块地均匀地分成方块，且分出的方块要尽可能大。如何将一块地均匀地分成方块，并确保分出的方块是最大的呢?使用D&C策略!D&C算法 是递归的。使用D&C解决问题的过程包括两个步骤：

* (1) 找出基线条件，这种条件必须尽可能简单。
* (2) 不断将问题分解(或者说缩小规模)，直到符合基线条件。

下面就来使用D&C找出前述问题的解决方案：

首先，找出基线条件。最容易处理的情况是，一条边的长度是另一条边的整数倍。如果一边长25 m，另一边长50 m，那么可使用的最大方块为 25 m×25 m。换言之，可以将 这块地分成两个这样的方块。

现在需要找出递归条件，这正是D&C的用武之地。根据D&C的定义，每次递归调用都必须 缩小问题的规模。如何缩小前述问题的规模呢?我们首先找出这块地可容纳的最大方块。最初要划分的土地尺寸为1680 m×640 m，你可以从这块地中划出两个640 m×640 m的方块，同时余下一小块地。现在是顿悟时刻:何不对余下的那一小块地使用相同的算法呢?

最初要划分的土地尺寸为1680 m×640 m，而现在要划分的土地更小，为640 m×400 m。适 用于这小块地的最大方块，也是适用于整块地的最大方块。换言之，你将均匀划分1680 m×640 m 土地的问题，简化成了均匀划分640 m×400 m土地的问题!

下面再次使用同样的算法。对于640 m × 400 m的土地，可从中划出的最 10 大方块为400 m × 400 m。这将余下一块更小的土地，其尺寸为400 m × 240 m。你可从这块土地中划出最大的方块，余下一块更小的土地，其尺寸为240 m × 160 m。接下来，从这块土地中划出最大的方块，余下一块更小的土地。余下的这块土地满足基线条件，因为160是80的整数倍。将这块土地分成两个方块后，将不会余下任何土地!因此，对于最初的那片土地，适用的最大方块为80 m× 80 m。

这里重申一下D&C的工作原理:

* (1) 找出简单的基线条件;
* (2) 确定如何缩小问题的规模，使其符合基线条件。 

D&C并非可用于解决问题的算法，而是一种解决问题的思路。

## 4.2快速排序

快速排序是一种常用的排序算法，比选择排序快得多。例如，C语言标准库中的函数qsort 实现的就是快速排序。快速排序也使用了D&C。

下面来使用快速排序对数组进行排序。对排序算法来说，最简单的数组什么样呢?

空数组或者只包含一个元素的数组，像这样的数组不需要排序。因此，基线条件为数组为空或只包含一个元素。在这种情况下，只需 原样返回数组——根本就不用排序。

```
def quickSort(array):
  if len(array) < 2:
      return array
```

我们来看看更长的数组。对包含两个元素的数组进行排序也很容易。检查第一个元素是否比第二个元素小，如果不比第2个元素小，就变换它们的位置。那么包含三个元素的数组呢？比如数组[33, 10 ,15]，别忘了，你要使用D&C，因此需要将数组分解，直到满足基线条件。下面介绍快速排序的工 作原理。首先，从数组中选择一个元素，这个元素被称为基准值(pivot)。我们暂时将数组的第一个元素用作基准值。

接下来，找出比基准值小的元素以及比基准值大的元素。这被称为分区(partitioning)。现在你有:

* 一个由所有小于基准值的数字组成的子数组;
* 基准值;
* 一个由所有大于基准值的数组组成的子数组。

这里只是进行了分区，得到的两个子数组是无序的。但如果这两个数组是有序的，对整个数 组进行排序将非常容易。如果子数组是有序的，就可以像下面这样合并得到一个有序的数组:左边的数组 + 基准值 + 右边的数组。在这里，就是[10, 15] + [33] + []，结果为有序数组[10, 15, 33]。

如何对子数组进行排序呢?对于包含两个元素的数组(左边的子数组)以及空数组(右边的 子数组)，快速排序知道如何将它们排序，因此只要对这两个子数组进行快速排序，再合并结果， 就能得到一个有序数组!

将任何元素用作基准值都可行，因此你能够对包含3个元素的数组进行排序。同理，你能够 对包含4个、5个、6个.....元素的数组进行排序，以此类推。

下面是快速排序的代码：

```
def quickSort(array):
    if len(array) < 2:
        #基线条件：为空或只包含一个元素的数组是“有序”的
        return array
    else:
        #递归条件
        pivot = array[0]
        #由所有小于基准值的元素组成的子数组
        less = [i for i in array[1:] if i <= pivot]
        #由所有大于基准值的元素组成的子数组
        greater = [i for i in array[1:] if i > pivot]
        return quickSort(less) + [pivot] + quickSort(greater)

print(quickSort([10, 5, 2, 3]))
#打印结果：[2, 3, 5, 10]
```

## 4.3 再谈大O表示法

快速排序的独特之处在于，其速度取决于选择的基准值。在讨论快速排序的运行时间前，我们再来看看最常见的大O运行时间。

![常见算法时间复杂度对比.png](https://upload-images.jianshu.io/upload_images/4164292-1d9df6a19648667b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

上述图表中的时间是基于每秒执行10次操作计算得到的。这些数据并不准确，这里提供它们 只是想让你对这些运行时间的差别有大致认识。实际上，计算机每秒执行的操作远不止10次。
对于每种运行时间，本书还列出了相关的算法。来看看第2章介绍的选择排序，其运行时间 为O(n<sup>2</sup>)，速度非常慢。

还有一种名为合并排序(merge sort)的排序算法，其运行时间为O(n log n)，比选择排序快得多！快速排序的情况比较棘手，在最糟情况下，其运行时间为O(n<sup>2</sup>)。与选择排序一样慢!但这是最糟情况。在平均情况下，快速排序的运行时间为O(n log n)。你 可能会有如下疑问：

* 这里说的最糟情况和平均情况是什么意思呢?
* 若快速排序在平均情况下的运行时间为O(n log n)，而合并排序的运行时间总是O(n log n)，为何不使用合并排序?它不是更快吗?

**比较合并排序和快速排序**

假设有下面这样打印列表中每个元素的简单函数。

```
def print_items(list): for item in list:
print(item)
```

这个函数遍历列表中的每个元素并将其打印出来。它迭代整个列表一次，因此运行时间为 O(n)。现在假设你对这个函数进行修改，使其在打印每个元素前都休眠1秒钟。

```
from time import sleep 
def print_items2(list):
for item in list: sleep(1)
print(item)
```

它在打印每个元素前都暂停1秒钟。假设你使用这两个函数来打印一个包含5个元素的列表。

这两个函数都迭代整个列表一次，因此它们的运行时间都为O(n)。你 认为哪个函数的速度更快呢?我认为print_items要快得多，因为它没有 在每次打印元素前都暂停1秒钟。因此，虽然使用大O表示法表示时，这两 个函数的速度相同，但实际上print_items的速度更快。在大O表示法O(n) 8 中，n实际上指的是这样的。

c是算法所需的固定时间量，被称为常量。例如，print_ items所需的时间可能是10毫秒 * n，而print_items2所需的时间为1秒 * n。通常不考虑这个常量，因为如果两种算法的大O运行时间不同，这种常量将无关紧要。

但有时候，常量的影响可能很大，对快速查找和合并查找来说就是如此。快速查找的常量比 合并查找小，因此如果它们的运行时间都为O(n log n)，快速查找的速度将更快。实际上，快速查 找的速度确实更快，因为相对于遇上最糟情况，它遇上平均情况的可能性要大得多。

**平均情况和最糟情况**

快速排序的性能高度依赖于你选择的基准值。假设你总是将第一个元素用作基准值，且要处理的数组是有序的。由于快速排序算法不检查输入数组是否有序，因此它依然尝试对其进行排序。

注意，数组并没有被分成两半，相反，其中一个子数组始终为空，这导致调用栈非常长。现 在假设你总是将中间的元素用作基准值，在这种情况下调用栈短得多!因为你每次都将数组分成两半，所以不需要那么多递归调用。你很快就到达 了基线条件，因此调用栈短得多。

在最糟情况下，栈长为 O(n)，而在最佳情况下，栈长为O(log n)。

在这个示例中，层数为O(log n)(用技术术语说，调用栈的高度为O(log n))，而每层需要的 时间为O(n)。因此整个算法需要的时间为O(n) * O(log n) = O(n log n)。这就是最佳情况。在最糟情况下，有O(n)层，因此该算法的运行时间为O(n) * O(n) = O(n2)。

这里要告诉你的是，最佳情况也是平均情况。只要你每次都随机地选择一个数组元 素作为基准值，快速排序的平均运行时间就将为O(n log n)。快速排序是最快的排序算法之一，也 是D&C典范。


## 4.4 本章小结

* D&C将问题逐步分解。使用D&C处理列表时，基线条件很可能是空数组或只包含一个元 素的数组。
* 实现快速排序时，请随机地选择用作基准值的元素。快速排序的平均运行时间为O(n log n)。
* 大O表示法中的常量有时候事关重大，这就是快速排序比合并排序快的原因所在。
* 比较简单查找和二分查找时，常量几乎无关紧要，因为列表很长时，O(log n)的速度比O(n)快得多。






