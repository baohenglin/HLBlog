# 第4章 快速排序

快速排序——一种常用的优雅的排序算法。快速排序使用分而治之的策略。我们将探索分而治之(divide and conquer，D&C)——一种著名的递归式问题解决方法。快速排序是一种排序算法，速 度比第2章介绍的选择排序快得多，实属优雅代码的典范。

## 4.1 分而治之

D&C并不那么容易掌握，我将通过三个示例来介绍。首先， 介绍一个直观的示例;然后，介绍一个代码示例，它不那么好看， 但可能更容易理解;最后，详细介绍快速排序——一种使用D&C的排序算法。

假设你是农场主，有一小块土地。你要将这块地均匀地分成方块，且分出的方块要尽可能大。如何将一块地均匀地分成方块，并确保分出的方块是最大的呢?使用D&C策略!D&C算法 是递归的。使用D&C解决问题的过程包括两个步骤：

* (1) 找出基线条件，这种条件必须尽可能简单。
* (2) 不断将问题分解(或者说缩小规模)，直到符合基线条件。

下面就来使用D&C找出前述问题的解决方案：

首先，找出基线条件。最容易处理的情况是，一条边的长度是另一条边的整数倍。如果一边长25 m，另一边长50 m，那么可使用的最大方块为 25 m×25 m。换言之，可以将 这块地分成两个这样的方块。

现在需要找出递归条件，这正是D&C的用武之地。根据D&C的定义，每次递归调用都必须 缩小问题的规模。如何缩小前述问题的规模呢?我们首先找出这块地可容纳的最大方块。最初要划分的土地尺寸为1680 m×640 m，你可以从这块地中划出两个640 m×640 m的方块，同时余下一小块地。现在是顿悟时刻:何不对余下的那一小块地使用相同的算法呢?

最初要划分的土地尺寸为1680 m×640 m，而现在要划分的土地更小，为640 m×400 m。适 用于这小块地的最大方块，也是适用于整块地的最大方块。换言之，你将均匀划分1680 m×640 m 土地的问题，简化成了均匀划分640 m×400 m土地的问题!

下面再次使用同样的算法。对于640 m × 400 m的土地，可从中划出的最 10 大方块为400 m × 400 m。这将余下一块更小的土地，其尺寸为400 m × 240 m。你可从这块土地中划出最大的方块，余下一块更小的土地，其尺寸为240 m × 160 m。接下来，从这块土地中划出最大的方块，余下一块更小的土地。余下的这块土地满足基线条件，因为160是80的整数倍。将这块土地分成两个方块后，将不会余下任何土地!因此，对于最初的那片土地，适用的最大方块为80 m× 80 m。

这里重申一下D&C的工作原理:

* (1) 找出简单的基线条件;
* (2) 确定如何缩小问题的规模，使其符合基线条件。 

D&C并非可用于解决问题的算法，而是一种解决问题的思路。

## 4.2快速排序

快速排序是一种常用的排序算法，比选择排序快得多。例如，C语言标准库中的函数qsort 实现的就是快速排序。快速排序也使用了D&C。

下面来使用快速排序对数组进行排序。对排序算法来说，最简单的数组什么样呢?

空数组或者只包含一个元素的数组，像这样的数组不需要排序。因此，基线条件为数组为空或只包含一个元素。在这种情况下，只需 原样返回数组——根本就不用排序。

```
def quickSort(array):
  if len(array) < 2:
      return array
```

我们来看看更长的数组。对包含两个元素的数组进行排序也很容易。检查第一个元素是否比第二个元素小，如果不比第2个元素小，就变换它们的位置。那么包含三个元素的数组呢？比如数组[33, 10 ,15]，别忘了，你要使用D&C，因此需要将数组分解，直到满足基线条件。下面介绍快速排序的工 作原理。首先，从数组中选择一个元素，这个元素被称为基准值(pivot)。我们暂时将数组的第一个元素用作基准值。

接下来，找出比基准值小的元素以及比基准值大的元素。这被称为分区(partitioning)。现在你有:

* 一个由所有小于基准值的数字组成的子数组;
* 基准值;
* 一个由所有大于基准值的数组组成的子数组。

这里只是进行了分区，得到的两个子数组是无序的。但如果这两个数组是有序的，对整个数 组进行排序将非常容易。如果子数组是有序的，就可以像下面这样合并得到一个有序的数组:左边的数组 + 基准值 + 右边的数组。在这里，就是[10, 15] + [33] + []，结果为有序数组[10, 15, 33]。

如何对子数组进行排序呢?对于包含两个元素的数组(左边的子数组)以及空数组(右边的 子数组)，快速排序知道如何将它们排序，因此只要对这两个子数组进行快速排序，再合并结果， 就能得到一个有序数组!

将任何元素用作基准值都可行，因此你能够对包含3个元素的数组进行排序。同理，你能够 对包含4个、5个、6个.....元素的数组进行排序，以此类推。

下面是快速排序的代码：

```
def quickSort(array):
    if len(array) < 2:
        #基线条件：为空或只包含一个元素的数组是“有序”的
        return array
    else:
        #递归条件
        pivot = array[0]
        #由所有小于基准值的元素组成的子数组
        less = [i for i in array[1:] if i <= pivot]
        #由所有大于基准值的元素组成的子数组
        greater = [i for i in array[1:] if i > pivot]
        return quickSort(less) + [pivot] + quickSort(greater)

print(quickSort([10, 5, 2, 3]))
#打印结果：[2, 3, 5, 10]
```

## 4.3 再谈大O表示法

快速排序的独特之处在于，其速度取决于选择的基准值。在讨论快速排序的运行时间前，我们再来看看最常见的大O运行时间。

![常见算法时间复杂度对比.png](https://upload-images.jianshu.io/upload_images/4164292-1d9df6a19648667b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

上述图表中的时间是基于每秒执行10次操作计算得到的。这些数据并不准确，这里提供它们 只是想让你对这些运行时间的差别有大致认识。实际上，计算机每秒执行的操作远不止10次。
对于每种运行时间，本书还列出了相关的算法。来看看第2章介绍的选择排序，其运行时间 为O(n2)，速度非常慢。

还有一种名为合并排序(merge sort)的排序算法，其运行时间为O(n log n)，比选择排序快 得多!快速排序的情况比较棘手，在最糟情况下，其运行时间为O(n2)。与选择排序一样慢!但这是最糟情况。在平均情况下，快速排序的运行时间为O(n log n)。







