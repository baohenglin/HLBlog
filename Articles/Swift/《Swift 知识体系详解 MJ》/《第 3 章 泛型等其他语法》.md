#### 四种实例初始化方法

```
//Person.self 是 Person 的原类型
class Person {
  static var age = 0 //类型属性 age
  static func run() {} //类型方法 run
}
Person.age = 10
Person.run() 
//原类型访问形式等价于上面代码
Person.self.age = 10
Person.self.run()
//这四种初始化方法等价，都是调用 init() 方法，分配堆空间内存进行初始化
var p0 = Person() //var p5 = type(of: p0).init()
var p1 = Person.self()
var p2 = Person.init()
var p4 = Person.self.init()
```

#### Person 和 Person.self 的异同

* 相同点：都能访问类型属性和类型方法；
* 不同点：元类类型 Person.self 可以直接赋值给一个变量，而 Person 不可以

```
var pType1 = Person.self
```

### 错误处理

#### 错误类型

错误类型包括语法错误（编译报错）、逻辑错误、运行时错误（可能会导致闪退，一般也叫做异常）、自定义错误。

Swift 中可以通过Error协议自定义运行时的报错信息。函数内部通过 throw 抛出自定义 Error，可能会抛出 Error 的函数必须加上 throws 声明。需要使用 try 调用可能会抛出 Error 的函数

```
enum SomeError : Error {
  case illegalArg(String)
  case outOfBounds(Int, Int)
  case outOfMemory
}
// 函数内部通过 throw 抛出自定义 Error，可能会抛出 Error 的函数必须加上 throws 声明。
func divide(_ num1: Int, _ num2: Int) throws -> Int {
  if num2 == 0 {
    throw SomeError.illegalArg("0不能作为除数")
  }
  return num1 / num2
}
var result = try divide(10, 0)
print(result)
```

处理 Error的 2 种方式：

* 通过 do-catch 捕捉Error
* 不捕捉 Error，在当前函数增加 throws 声明，Error 将自动抛给上层函数。如果最顶层函数（main函数）依然没有捕捉Error，那么程序将终止。

#### 使用 do-catch 捕捉 Error

```
func test() {
  print("1")
  do {
    print("2")
    print(try divide(20, 0))
    print("3")
  } catch let SomeError.illegalArg(msg) {
    print("参数异常：", msg)
  } catch let SomeError.outOfBounds(size, index) {
    print("下标越界：", "size=\(size)", "index=\(index)")
  } catch SomeError.outOfMemory {
    print("内存溢出")
  } catch {
    print("其他错误")
  }
  print("4")
}
test()
```

抛出 Error 后，try下一句直到作用域结束的代码都将停止运行。

```
func test() throws {
  print("1")
  do {
    print("2")
    print(try divide(20, 0))
    print("3")
  } catch let error SomeError {
    print(error)
  }
  print("4")
}
try test()
//1
//2
// illegalArg("0不能作为除数")
//4
```

```
do {
  print(try divede(20, 0))
} catch is SomeError {
  print("SomeError")
}
```

#### try?、try!








