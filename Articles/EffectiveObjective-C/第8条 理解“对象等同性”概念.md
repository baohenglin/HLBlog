## 对象等同性

### 要点：

* 若想检测对象的等同性，请提供“isEqual:”与hash 方法。
* 相同的对象必须具有相同的哈希码，但是两个哈希码相同的对象却未必相同。
* 不要盲目地逐个检测每条属性，而是应该依照具体需求来制定检测方案。
* 编写 hash 方法时，应该使用计算速度快而且哈希码碰撞机率低的算法。

根据“等同性”（equality）来比较对象是一个非常有用的功能。不过，按照 == 操作符比较出来的结果未必是我们想要的，**因为“==”该操作比较的是两个指针本身，而不是其所指的对象。应该使用 NSObject 协议中声明的“isEqual:”方法来判断两个对象的等同性**。一般来说，两个类型不同的对象总是不相等的（unequal）。某些对象提供了特殊的“等同性判定方法”（equality-checking method），如果已经知道两个受测对象都属于同一个类，那么就可以使用这种方法。

以下述代码为例：

```
NSString *foo = @"Badger 123";
NSString *bar = [NSString stringWithFormat:@"Badger %i",123];
BOOL equalA = (foo == bar); //equalA = NO
BOOL equalB = [foo isEqual:bar];  //equalB = YES
BOOL equalC = [foo isEqualToString:bar];  //equalC = YES
```

我们可以看到"=="与等同性判断方法之间的差别。NSString 类实现了一个自己独有的等同性判断方法，名叫“isEqualToString:”。传递给该方法的对象必须是 NSString，否则结果未定义（undefined）。**调用“isEqualToString:”方法比调用“isEqual:”方法快，后者还要执行额外的步骤，因为它不知道受测对象的类型**。

NSObject 协议中有两个用于判断等同性的关键方法：

```
- (BOOL)isEqual:(id)object;
- (NSUInteger)hash;
```

NSObject类对这两个方法的默认实现是：**当且仅当其“指针值”（pointer value）完全相等时，这两个对象才相等。若想在自定义的对象中正确覆写这些方法，就必须先理解其约定（contract）。如果“isEqual:”方法判定两个对象相等，那么其hash方法也必须返回同一个值。但是，如果两个对象的hash方法返回同一个值，那么“isEqual:”方法未必会认为两者相等**。

比如有下面这个类：

```
@interface EOCPerson : NSObject
@property (nonatomic, copy) NSString *firstName;
@property (nonatomic, copy) NSString *lastName;
@property (nonatomic, assign) NSInteger age;
```

我们认为，如果两个 EOCPerson 的所有字段均相等，那么这两个对象就相等。于是“isEqual:”方法可以写成：

```
- (BOOL)isEqual:(id)object {
    if(self == object) return YES;
    if([self class] != [object class]) return NO;
    EOCPerson *otherPerson = (EOCPerson *)object;
    if(![_firstName isEqualToString:otherPerson.firstName])
        return NO;
    if(![_lastName isEqualToString:otherPerson.lastName])
        return NO;
    if(_age != otherPerson.age)
        return NO;
    return YES;
}
```






