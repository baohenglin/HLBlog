#### 四种实例初始化方法

```
//Person.self 是 Person 的原类型
class Person {
  static var age = 0 //类型属性 age
  static func run() {} //类型方法 run
}
Person.age = 10
Person.run() 
//原类型访问形式等价于上面代码
Person.self.age = 10
Person.self.run()
//这四种初始化方法等价，都是调用 init() 方法，分配堆空间内存进行初始化
var p0 = Person() //var p5 = type(of: p0).init()
var p1 = Person.self()
var p2 = Person.init()
var p4 = Person.self.init()
```

#### Person 和 Person.self 的异同

* 相同点：都能访问类型属性和类型方法；
* 不同点：元类类型 Person.self 可以直接赋值给一个变量，而 Person 不可以

```
var pType1 = Person.self
```

### 错误处理

#### 错误类型

错误类型包括语法错误（编译报错）、逻辑错误、运行时错误（可能会导致闪退，一般也叫做异常）、自定义错误。

Swift 中可以通过Error协议自定义运行时的报错信息。函数内部**通过 throw 抛出自定义 Error，可能会抛出 Error 的函数必须加上 throws 声明。需要使用 try 调用可能会抛出 Error 的函数**

```
enum SomeError : Error {
  case illegalArg(String)
  case outOfBounds(Int, Int)
  case outOfMemory
}
// 函数内部通过 throw 抛出自定义 Error，可能会抛出 Error 的函数必须加上 throws 声明。
func divide(_ num1: Int, _ num2: Int) throws -> Int {
  if num2 == 0 {
    throw SomeError.illegalArg("0不能作为除数")
  }
  return num1 / num2
}
var result = try divide(10, 0)
print(result)
```

处理 Error的 2 种方式：

* 通过 do-catch 捕捉Error
* 不捕捉 Error，在当前函数增加 throws 声明，Error 将自动抛给上层函数。如果最顶层函数（main函数）依然没有捕捉Error，那么程序将终止。

#### 使用 do-catch 捕捉 Error

```
func test() {
  print("1")
  do {
    print("2")
    print(try divide(20, 0))
    print("3")
  } catch let SomeError.illegalArg(msg) {
    print("参数异常：", msg)
  } catch let SomeError.outOfBounds(size, index) {
    print("下标越界：", "size=\(size)", "index=\(index)")
  } catch SomeError.outOfMemory {
    print("内存溢出")
  } catch {
    print("其他错误")
  }
  print("4")
}
test()
```

**抛出 Error 后，try下一句直到作用域结束的代码都将停止运行**。

```
func test() throws {
  print("1")
  do {
    print("2")
    print(try divide(20, 0))
    print("3")
  } catch let error SomeError {
    print(error)
  }
  print("4")
}
try test()
//1
//2
// illegalArg("0不能作为除数")
//4
```

```
do {
  print(try divede(20, 0))
} catch is SomeError {
  print("SomeError")
}
```

#### try?、try!

可以**使用 try?、try! 调用 可能会抛出 Error 的函数，这样就不用去处理 Error**。

```
func test() {
  print("1")
  var result1 = try? divide(20, 10) //Options(2), Int?
  var result2 = try? divide(20, 0) //nil
  var result3 = try! divide(20, 10) //2, Int
  print("2")
}
test()
```

```
//a、b是等价的：
var a = try? divide(20, 0)
var b: Int?
do {
  b = try divide(20, 0)
} catch { b = nil }
```

#### rethrows

rethrows 是用来表明**函数本身不会抛出错误，但调用闭包参数抛出错误，那么它会将错误向上抛。**

```
func exec(_ fn: (Int, Int) throws -> Int, _ num1: Int, _ num2: Int) rethrows {
  print(try fn(num1, num2))
}
//Fatal error: Error raised at top level
try exec(divide, 20, 0)
```

#### defer 

defer语句用来**定义以任何方式（抛错误、return等）离开代码块前必须要执行的代码。defer 语句将延迟至当前作用域结束之前执行**。

```
func open(_ filename: String) -> Int {
  print("open")
  return 0
}
func close(_ file: Int) {
  print("close")
}
func processFile(_ filename: String) throws {
  let file = open(filename)
  defer {
    close(file)
  }
  // 使用 file
  // ....
  try divide(20, 0)
  //close将会在这里调用
}
try processFile("test.txt")
// open
// close
// Fatal error: Error raised at top level
```

**defer 语句的执行顺序与定义顺序相反**。

```
func fn1() { print("fn1") }
func fn2() { print("fn2") }
func test() {
  defer { fn1() }
  defer { fn2() }
}
test()
// fn2 
// fn1
```

### 泛型（Generics）

泛型可以将类型参数化，提高代码复用率，减少代码量。


#### 泛型函数

```
var n1 = 10
var n2 = 20
func swapValues(_ a: inout Int, _ b: inout Int) {
  (a, b) = (b, a)
}
func swapValues(_ a: inout Double, _ b: inout Double) {
  (a, b) = (b, a)
}
swapValues(&n1, &n2)
```

```
func swapValues<T>(_ a: inout T, _ b: inout T) {
  (a, b) = (b, a)
}
var n1 = 10
var n2 = 20
swapValues(&n1, &n2)

var d1 = 10.0
var d2 = 20.0
swapValues(&d1, &d2)

var f1 = Date(year: 2011, month: 9, day: 10)
var f2 = Date(year: 2012, month: 10, day: 11)
swapValues(&f1, &f2)
```

**泛型函数赋值给变量**

```
func test<T1, T2>(_ t1: T1, _ t2: T2) {}
var fn: (Int Double) -> () = test
```

#### 泛型类型

```
//类
class Stack<E> {
  var elements = [E]()
  func push(_ element: E) { elements.append(element) }
  func pop() -> E { elements.removeLast() }
  func top() -> E { elements.last! }
  func size() -> Int { elements.count }
}

var stack = Stack<Int>()
stack.push(11)
stack.push(12)
stack.push(13)
print(stack.top()) //33
print(stack.pop()) //33
print(stack.pop()) //22
print(stack.pop()) //11
print(stack.size) // 0
```

```
// 结构体
struct Stack<E> {
  var elements = [E]()
  mutating func push(_ element: E) { elements.append(element) }
  mutating func pop() -> E { elements.removeLast() }
  func top() -> E { elements.last! }
  func size() -> Int { elements.count }
}
```

```
// 枚举
enum Score<T> {
  case point(T)
  case grade(String)
}
let score0 = Score<Int>.point(100)
let score1 = Score.point(99)
let score2 = Score.point(99.5)
let score3 = Score<Int>.grade("A")
```

### 关联类型

关联类型的作用：给协议中用到的类型定义一个占位名称（协议通过关联类型来实现泛型）。协议中可以拥有多个关联类型。

```
protocol Stackable {
  associatedtype Element //关联类型
  mutating func push(_ element: Element)
  mutating func pop() -> Element
  func top() -> Element
  func size() -> Int
}
```

```
class StringStack : Stackable {
  //给关联对象设置真实类型
  typealias Element = String
  var elements = [String]()
  func push(_ element: String) { elements.append(element) }
  func pop() -> String { elments.removeLast() }
  func top() -> String { elements.last! }
  func size() -> Int { elements.count }
}
var ss = StringStack()
ss.push("Jack")
ss.push("Rose")
```

```
class Stack<E> : Stackable {
  // typealias Element = E
  var elements = [E]()
  func push(_ element: E) {
     elements.append(element)
  }
  func pop() -> E { elements.removeLast() }
  func top() -> E { elements.last! }
  func size() -> Int { elements.count }
}
```

#### 关联约束

```
//关联约束
protocol Runnable { }
class Person { }
func swapValues<T : Person & Runnable>(_a: inout T, _ b: inout T) {
  (a, b) = (b, a)
}
```

```
protocol Stackable {
  associatedtype Element: Equatable // Equatable 是一种协议
}
class Stack<E : Equatable> : Stackable { }
```

```
func equal<S1: Stackable, S2: Stackable>(_ s1: S1, _ s2: S2) -> Bool
  //S1的关联类型和S2的关联类型必须相同，比如都是 Int 类型，并且 S1的关联类型必须遵守 Hashable 协议。
  where S1.Element == S2.Element, S1.Element : Hashable
{
  return false
}
var s1 = Stack<Int>()
var s2 = Stack<Int>()
var s3 = Stack<String>()
equal(s1, s2) //不报错
equal(s1, s3) //报错
```

#### 协议类型的注意点

```
protocol Runnable {
  associatedtype Speed
  var speed: Speed { get }
}
class Person : Runnable {
  var speed: Double { 0.0 }
}
class Car : Runnable {
  var speed: Int { 0 }
}
func get(_ type: Int) -> Runnable { //报错“Protocol 'Runnable' can only be used as a generic constraint because is has Self or associated type requirements”
  if type == 0 {
    return Person()
  }
  return Car()
}
var r1 = get(0)
var r2 = get(1)
```

那么如何解决上述报错呢？

##### 方案1：使用泛型

```
func get<T : Runnable>(_ type: Int) -> T {
  if type == 0 {
    return Person() as! T
  }
  return Car() as! T
}
var r1: Person = get(0)
var r2: Car = get(1)
```


##### 方案2：不透明类型（Opaque Type）

使用 some 关键字声明一个不透明类型。不透明类型只能返回一种类型。

应用场景：只想返回遵守了某协议的对象，只暴露协议里定义的接口，而不想暴露该对象的具体类型。此时就可以使用 some 关键字声明一个不透明类型。

```
protocol Runnable {
  associatedtype Speed
  var speed: Speed { get }
}
class Person : Runnable {
  var speed: Double { 0.0 }
}
class Car : Runnable {
  var speed: Int { 0 }
  func run() {}
}
func get(_ type: Int) -> some Runnable {
  return Car() // 不透明类型只能返回一种类型。
}
var r1 = get(0)
var r2 = get(1)
```

**some 除了用在返回值类型上，一般还可以用在属性类型上**。

```
protocol Runnable { associatedtype Speed }
class Dog : Runnable ( typealias Speed = Double )
class Person {
  var pet: some Runnable {
    return Dog()
  }
}
```

