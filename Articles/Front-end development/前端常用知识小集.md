# 知识小集

## sessionStorage 缓存信息

```
//把 sessionStoreObj 对象信息以字符串的形式缓存到 sessionStorage
sessionStorage.setItem('applicationInformationObj', JSON.stringify(sessionStoreObj || '{}'));

//从 sessionStorage 中读取缓存的信息
let applicationInforObj = JSON.parse(sessionStorage.getItem('applicationInformationObj'));
```

## localStorage 缓存信息

```
//存储
localStorage.setItem('dynamicMenuRoutes', JSON.stringify(listArr || '[]'));
//读取 
let menuRoutesArr = JSON.parse(localStorage.getItem('dynamicMenuRoutes'));
//删除
localStorage.remove('dynamicMenuRoutes');
//清空
localStorage.clear();
```

## Vue 实例的生命周期

[Vue 实例的生命周期](https://www.cnblogs.com/wangyuxue/p/11803536.html)

Vue 实例的生命周期是指从 Vue 实例创建初始化到运行再到销毁期间所伴随着的各种各样的事件。这些事件统称为生命周期。这些**生命周期事件**也称为**生命周期函数**或**生命周期钩子**。

整个生命周期函数分为三大类：

* 创建期间的生命周期函数

```
beforeCreate 函数：实例刚在内存中被创建出来，此时还没有初始化完成 data 和 methods 属性。
created 函数：实例已经在内存中创建完成，data 和 methods 也已经创建完成。但是此时还没有开始编译模板。
beforeMount 函数：此时已经完成模板编译，但是还没有挂载到页面中。
mounted 函数：此时已将编译好的模板挂载到了页面指定的容器中显示。
```
* 运行期间的生命周期函数

```
beforeUpdate 函数：状态更新之前执行此函数，此时 data 中的状态值是最新的，但是页面上显示的数据还是旧值。此时还没有开始重新渲染 DOM 节点。
updated 函数：实例更新完毕之后调用此函数，此时 data 中的状态值和界面上显示的数据都已经完成了更新，界面已经被重新渲染。
```
* 销毁期间的生命周期函数

```
beforeDestroy 函数：实例销毁之前调用该函数。此时，实例仍然完全可用。
destroyed 函数：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器都会被移除，所有的子组件也会被销毁。
```

## 隐藏滚动条

```
::-webkit-scrollbar {
 width: 0 !important;
}
::-webkit-scrollbar {
 width: 0 !important;height: 0;
}
```

## 原生JS上传文件

```
// 预览文件
previewFile: {
    type: '',
    src: '',
    file: '',
    loading: false
},
<script>
// 选择文件并预览
  previewFun() {
    this.previewFile.loading = true
    let files = this.$refs.choseFile.files[0]
    console.log('上传文件：',files)
    this.previewFile.file = files
    this.previewFile.type = files.type.split('/')[0]
    let readerFile = new FileReader()
    readerFile.readAsDataURL(files)
    let that = this;
    readerFile.onload = function (ev) {
        that.$set(that.previewFile, 'src', ev.target.result)
        console.log('上传成功：',ev.target.result);
        that.$set(that.previewFile, 'loading', false);
        that.dialogForm.dialogForm_uploadFile = ev.target.result.split('base64,')[1];
    }
  },
</script>
<el-button
    v-if="operateType !== 'detail'"
    size="medium"
    class="upload-btn-wrap"
    :loading="previewFile.loading">
    <i class="el-icon-upload el-icon--left upload-icon"></i>
    选择文件
    <input
    type="file"
    class="chose-file"
    accept="audio/*,video/*,image/*"
    ref="choseFile"
    @change="previewFun"/> 
</el-button>
<div class="preview-file-wrap">
    <img
    v-if="previewFile.type === 'image'"
    :src="previewFile.src"
    alt="img"
    class="files"
    />
    <audio
    v-if="previewFile.type === 'audio'"
    :src="previewFile.src"
    class="files"
    controls
    preload
    ></audio>
    <video
    v-if="previewFile.type === 'video'"
    :src="previewFile.src"
    class="files"
    preload
    controls
    muted
    ></video>
</div>
```

## Vue 中监听页面刷新、关闭操作

[监听页面刷新、关闭操作](https://www.cnblogs.com/wxh0929/p/11732716.html)


## 数组去重

### 1. 对象元素去重方法

```
/**
   * 过滤数组中的重复对象
   * @param {*} objArr 待处理数组
   * @param {*} paramsName 比较的属性名称
   */
  export function deteleObject(objArr, paramsName) {
    let obj = {};
    let finalArr = objArr.reduce((cur,next) => {
        console.log('11111:',cur, next);
        obj[next[paramsName]] ? "" : obj[next[paramsName]] = true && cur.push(next);
        return cur;
    }, []) //设置cur默认类型为数组，并且初始值为空的数组
    return finalArr;
}
```

### 2. 字符元素去重

```
const arr = ['张三','张三','三张三']
let set = new Set(arr); // Set 自带去重
console.log(set);
//{ '张三', '三张三' }
```

## src和href的区别

[src和href的区别](https://www.cnblogs.com/kuai-man/p/10578158.html)


## script标签中defer和async 的区别

[script标签中defer和async 的区别](https://juejin.cn/post/6844903955709820935)

## 前端有哪几种数据缓存方式？它们的区别是什么？

cookies、localstorage、sessionstorage、Web SQL、IndexedDB


# CSS 部分

## CSS 选择器的优先级是怎样的？

CSS选择器的优先级是：**内联 > ID选择器 > 类选择器 > 标签选择器**

具体的计算规则如下：

优先级由 A、B、C、D 的值来决定。其中，

* A 的值等于 1 的前提是存在内联样式，否则 A = 0；
* B 的值等于 ID 选择器出现的次数；
* C 的值等于 类选择器、属性选择器和伪类出现的总次数；
* D 的值等于 标签选择器和伪元素出现的总次数。

比如下面的选择器

```
//选择器1
ul ol li .red {

}
```

由于选择器1不存在内联样式，所以 A = 0；不存在 id选择器，因此 B = 0；存在一个类选择器，因此 C = 1；存在3个标签选择器，因此 D = 3，那么最终权重计算结果为：{0, 0, 1, 3}。

```
//选择器2
#red {

}
```

选择器2的权重计算结果为：{0, 1, 0, 0}。

我们比较优先级的方法是从A到D依次一一比较值的大小（A、B、C、D权重从左到右依次减小），直到比较出最大值，即可停止。比如选择器2的B值与选择器1的B值相比，1>0，接下来就不需要比较了，选择器2的优先级更高。


## 清除浮动的方法有哪些？

[清除浮动的几种方法](https://juejin.cn/post/6844904006834192398)




















