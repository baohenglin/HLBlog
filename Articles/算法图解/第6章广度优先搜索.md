# 第六章 广度优先搜索

## 本章内容

* 学习使用新的数据结构图来建立网络模型
* 学习广度优先搜索，你可对图使用这种算法回答诸如“到X的最短路径是什么”等问题。
* 学习有向图和无向图。
* 学习拓扑排序，这种排序算法指出了节点之间的依赖关系。

本章将介绍图。首先，我将说说什么是图(它们不涉及X轴和Y轴)，再介绍第一种图算法—— 广度优先搜索(breadth-first search，BFS)。

广度优先搜索让你能够找出两样东西之间的最短距离，不过最短距离的含义有很多!使用广 度优先搜索可以:

* 编写国际跳棋AI，计算最少走多少步就可获胜;
* 编写拼写检查器，计算最少编辑多少个地方就可将错拼的单词改成正确的单词，如将READED改为READER需要编辑一个地方;
* 根据你的人际关系网络找到关系最近的医生。

## 图简介

**最短路径问题**(shorterst-path-problem)，解决最短路径问题的算法被称为**广度优先搜索**。

关于解决最短路径问题，需要两个步骤：

* (1)使用图来建立问题模型
* (2)使用广度优先搜索解决问题。

图由节点（node）和边（edge）组成。一个节点可能与众多节点直接相连，这些节点被称为邻居。

广度优先搜索是一种用于图的查找算法，可帮助回答两类问题。

* (1)第一类问题：从节点A出发，有前往节点B的路径吗？
* (2)第二类问题：从节点A出发，前往节点B的哪条路径最短？

比如你需要寻找一位芒果经销商，你不仅可以在你的朋友中查找，还可以在朋友的朋友中查找。使用这种算法将搜遍你的整个人际关系网，直到找到芒果经销商。这就是广度优先搜索算法。

## 查找最短路径

广度优先搜索不仅查找从A到B的路径，而且找到的是最短的路径。

**队列**的工作原理与现实生活中的队列完全相同。假设你与朋友一起在公交车站排队，如果你排在他前面，你将先上车。队列的工作原理与此相同。队列只支持两种操作：入队和出队。

如果你将两个元素加入队列，先加入的元素将在后加入的元素之前出队。因此，你可使用队列来表示查找名单！这样，先加入的人将先出队并先被检查。

队列是一种先进先出（First In First Out，FIFO）的数据结构，而栈是一种后进先出（Last In First Out，LIFO）的数据结构。

## 实现图

可以使用**散列表**来实现图。散列表能够将键映射到值。

```
graph = {}
graph["you"] =  ["alice", "bob", "claire"]
```

散列表是无序的，因此添加键-值对的顺序无关紧要。有剪头指向某节点但是没有从该节点指向节点的箭头，这被称为有向图。其中的关系是单向的。无向图没有箭头，直接相连的节点互为邻居。

## 实现算法

该算法的工作原理如下：

* 1.创建一个队列，用于存储要检查的人；
* 2.从队列中弹出一个人；
* 3.检查这个人是否是芒果销售商；
* 4.如果是芒果销售商，则大功告成；
* 5.如果不是，则将这个人的所有邻居都加入队列，继续重复第2步；
* 6.如果队列为空，就说明你的人际关系网中没有芒果销售商。

代码如下：

```
def search(name):
  search_queue = deque()
  search_queue += graph[name]
  //这个数组用于记录检查过的人
  searched = []
  while search_queue:
    person = search_queue.popleft()
    if person_is_seller(person):
      print person + " is a mango seller!"
      return Ture
    else:
      search_queue += graph[person]
      searched.append(person)//将这个人标记为检查过。对于检查过的人，务必不要再去检查，否则可能导致无限循环。
  return False
```

## 运行时间

如果你在你的整个人际关系网中搜索芒果销售商，就意味着你将沿每条边前行（边是从一个人到另一个人的箭头或连接），因此运行时间至少为O(边数)。此外还使用了一个队列，其中包含要检查的每个人。将一个人添加到队列需要的时间是固定的，即为O(1)，因此对每个人都这样做需要的总时间为O(人数)。所以，广度优先搜索的运行时间为O(人数+边数)，通常写作O(V + E)，其中V为顶点，E为边数




