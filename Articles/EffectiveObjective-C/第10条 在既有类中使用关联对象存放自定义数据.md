## 第10条 在既有类中使用关联对象存放自定义数据

### 要点：

* 可以通过“关联对象”机制来把两个对象连起来。
* 定义关联对象时可指定内存管理语义，用以模仿定义属性时所采用的“拥有关系”与“非拥有关系”。
* 只有在其他做法不可行时才应选用关联对象，因为这种做法通常会引入难于查找的 bug。

有时需要在对象中存放相关信息。这时我们通常会从对象所属的类中继承一个子类，然后改用这个子类对象。然而并非所有情况下都能这么做，有时候类的实例可能是由某种机制所创建的，而开发者无法令这种机制创建出自己所写的子类实例。Objective-C中有一项强大的特性可以解决此问题，这就是“关联对象”（Associated Object）。

可以给某对象关联许多其他对象，这些对象通过“键”来区分。存储对象值的时候，可以指明“存储策略”（storge policy），用以维护相应的“内存管理语义”。存储策略由名为 objc_AssociationPolicy 的枚举所定义，下表列出了该枚举的取值，同时还列出了与之等效的 @property 属性：假如关联对象成了属性，那么它就会具备对应的语义。

|关联类型|等效的 @property|
|:---|:--|
|OBJC_ASSOCIATION_ASSIGN|assign|
|OBJC_ASSOCIATION_RETAIN_NONATOMIC|nonatomic,retain|
|OBJC_ASSOCIATION_COPY_NONATOMIC|nonatomic,copy|
|OBJC_ASSOCIATION_RETAIN|retain|
|OBJC_ASSOCIATION_COPY|copy|

下列方法可以管理关联对象：

* void objc_setAssociatedObject(id object, void* key,id value, objc_AssociationPolicy policy)

此方法以给定的键和策略为某对象设置关联对象值。

* id objc_getAssociatedObject(id object, void* key)

此方法根据给定的键从某对象中获取相应的关联对象值。

* void objc_removeAssociatedObjects(id object)

此方法移除指定对象的全部关联对象。

我们可以把对象想象成 NSDictionary，把关联到该对象的值理解为字典中的条目，于是，存取关联对象的值就相当于在 NSDictionary对象上调用 [object setObject:valueforKey:key]与[object objectForKey:key]方法。然而两者之间有个重要差别：设置关联对象时用的键（key）是个“不透明的指针”(opaque pointer)。如果在两个键上调用“isEqual:”方法的返回值是 YES，那么 NSDictionary 就认为二者相等；然而在设置关联对象值时，若想令两个键匹配到同一个值，则二者必须是完全相同的指针才行。鉴于此，在设置关联对象值时，通常使用静态全局变量做键




