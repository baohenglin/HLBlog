# 第4章 变量、作用域与内存

## 4.1 原始值与引用值

ECMAScript 变量包含两种不同类型的数据：原始值和引用值。原始值就是最简单的数据（Undefined、Null、Boolean、Number、String和Symbol），引用值则是由多个值构成的对象。

保存原始值的变量是按值（by value）访问的（此时操作的就是存储在变量中的实际值）；保存引用值的变量是按引用（by reference）访问的（在操作对象时，实际上操作的是对该对象的引用而非实际的对象本身）

### 4.1.1 动态属性

对于引用值，可以随时添加、修改和删除其属性和方法。

```
let person = new Object();
person.name = "Nicholas";
console.log(person.name); 
// “Nicholas”
```

**只有引用值可以动态添加后面可以使用的属性**。

注意，原始类型的初始化可以只使用原始字面量形式。如果使用的是 new 关键字，则 Javascript 会创建一个 Object 类型的实例，但其行为类似原始值。下面看看这两种初始化方式的差异：

```
let name1 = "Bao";
let name2 = new String("HL");
name1.age = 20;
name2.age = 18;
console.log(name1.age); // undefined
console.log(name2.age); // 18
console.log(typeof name1); // string
console.log(typeof name2); // object
```


### 4.1.2 复制值

除了存储方式不同，原始值和引用值在通过变量复制时也有所不同。在通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置。

```
let num1 = 5;
let num2 = num1;
```

num1包含数值5。当把 num2 初始化为 num1 时，num2 也会得到数值 5。这个值跟存储在 num1 中的5是完全独立的，因为它是哪个值的副本。这两个变量可以独立使用，互不干扰。

在把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。区别在于，这里**复制的值实际上是一个指针，它指向存储在堆内存中的对象**。操作完成后，两个变量实际上指向同一个对象，因此一个对象属性值的变化会影响另一个对象。

```
let obj1 = new Object();
let obj2 = obj1;
obj1.name = "BaoHL";
console.log(obj2.name); // "BaoHL"
```

### 4.1.3 传递参数（not understand）

**ECMAScript 中所有函数的参数都是按值传递的**。这意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样。如果是原始值，那么就跟原始值变量的复制一样；如果是引用值，那么就就跟引用值变量的复制一样。这一块可能会不好理解，毕竟变量有按值和按引用访问，而传参则只有按值传递。

### 4.1.4 确定类型（instanceof 操作符）

instanceof 操作符可以用来确定某个对象是什么类型的对象。

```
console.log(person instanceof Object); //变量 person 是否是 Object 类型
console.log(person instanceof Array); //变量 person 是否是 Array 类型
console.log(person instanceof RegExg); //变量 person 是否是 RegExg 类型
```

## 4.2 执行上下文与作用域

执行上下文（以下简称“上下文”）的概念在 JavaScript 中是颇为重要的。变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行文。

### 4.2.1 作用域链增强

### 4.2.2 变量声明

#### 4.2.2.4 标识符查找

当在特定上下文中为读取或写入而引入一个标识符时，必须通过搜索确定这个标识符表示什么。搜索开始于作用域链前端，以给定的名称搜索对应的标识符。如果在局部上下文中找到该标识符，则搜索停止，标量确定；如果没有找到变量名，则继续沿作用域链搜索。（注意，作用域链中的对象也有一个原型链，因此搜索可能涉及每个对象的原型链。）这个过程一直持续到搜索至全局上下文的变量对象。如果仍然没有找到标识符，则说明其未声明。





