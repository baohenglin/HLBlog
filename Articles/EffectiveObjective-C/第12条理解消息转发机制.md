# 第12条 理解消息转发机制

第11条讲解了对象的消息传递机制，并强调了其重要性。第12条则要讲解另外一个重要的问题，就是对象在收到无法解读的消息之后会发生什么情况。

如果想让类能理解某条消息，我们必须通过代码来实现其对应的方法。但是，在编译期向类发送了其无法解读的消息并不会报错，因为在运行期可以继续向类中添加方法，所以编译器在编译时还无法确定类中到底会不会有某个方法的实现。当对象接收到无法解读的消息后，就会启动“消息转发”(message forwarding)机制，程序员可经由此过程告诉对象该如何处理未知消息。

```
2019-08-07 18:47:22.014341+0800 InterviewQuestionsCollection[30209:1924891] -[HLPerson run]: unrecognized selector sent to instance 0x600002c7c4d0
2019-08-07 18:47:22.023878+0800 InterviewQuestionsCollection[30209:1924891] *** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[HLPerson run]: unrecognized selector sent to instance 0x600002c7c4d0'
```

上面的报错信息就是因为向实例对象发送了一条其无法解析的消息，从而启动了消息转发机制以应用程序崩溃而告终。不过，开发者在编写自己的类时，可以在转发过程中设置挂钩，用以执行预定的逻辑，而不使应用程序崩溃。

消息转发分为两大阶段。第一阶段先看接收者是否能动态添加方法，已处理当前这个“未知的选择子”，这叫做“动态方法解析”(dynamic method resolution)。第二阶段是“完整的消息转发机制”(full forwarding mechanism)。如果运行期系统已经把第一阶段执行完了，那么接收者自己就无法以动态新增方法的手段来响应包含该选择子的消息了。此时，运行期系统会请求接收者以其他手段来处理与消息相关的方法调用。这又细分为两小步。首先，请接收者看看有没有其他对象能处理这条消息。如果有，则运行期系统会把该消息转发给那个对象，于是消息转发过程结束，一切如常。如果没有“备援的接收者”(replacement receiver)，则启动完整的消息转发机制，运行期系统会把与消息有关的全部细节都封装到NSInvocation对象中，再给接收者最后一次机会，令其设法解决当前还未处理的这条消息。

## 动态方法解析

对象在收到无法解读的消息后，首先将调用其所属类的以下类方法：

```
+ (BOOL)resolveInstanceMethod:(SEL)selector
```

该方法的参数就是那个未知的选择子，其返回值为Boolean类型，表示这个类是否能新增一个实例方法用以处理此选择子。在继续往下执行转发机制之前，本类有机会新增一个处理此选择子的方法。假如尚未实现的方法不是实例方法而是类方法，那么运行期系统就会调用另外一个方法，该方法与“resolveInstanceMethod:”类似，叫做"resolveClassMethod:"。

使用这种办法的前提是：相关方法的实现代码已经写好，只等着运行的时候动态插在类里面就可以了。此方案常用来实现@dynamic属性（参见第6条），比如说，要访问CoreData框架中NSManagedObjects对象的属性时就可以这么做，因为实现这些属性所需的存取方法在编译器就能确定。

下面代码演示了如何用"resolveInstanceMethod:"来实现@dynamic属性：

```
id autoDictionaryGetter(id self, SEL _cmd);
void autoDictionarySetter(id self, SEL _cmd, id value);

+ (BOOL)resolveInstanceMethod:(SEL)selector {
  NSString *selectorString = NSStringFromSelector(selector);
  if (/* selector is from a @dynamic property */) {
    if ([selectorString hasPrefix:@"set"]) {
      class_addMethod(self, selector, (IMP)autoDictionarySetter,"v@:@");
    } else {
      class_addMethod(self, selector, (IMP)autoDictionaryGetter, "@@:");
    }
    return YES;
  }
  return [super resolveInstanceMethod:selector];
}
```

首先将选择子化为字符串，然后检测其是否表示设置方法。如果前缀是set，则表示设置方法，否则就是获取方法。不管哪种情况，都会把处理该选择子的方法加到类里面，所添加的方法是用纯C函数实现的。C函数可能会用代码来操作相关的数据结构，类之中的属性数据就存放在那些数据结构里面。以CoreData为例，这些存取方法也许要和后端数据库通信，以便获取或更新相应的值。

## 备援接收者

当前接收者还有第二次机会来处理未知的选择子，在这一步中，运行期系统会问它：能不能把这条消息转给其他消息接收者来处理。与该步骤对应的处理方法如下：

```
- (id)forwardingTargetForSelector:(SEL)selector
```

方法参数代表未知的选择子，如果当前接收者能找到备援对象，则将其返回；如果找不到，就返回nil。通过此方案，我们可以用“组合”(composition)来模拟出“多重继承”(multiple inheritance)的某些特性。在一个对象内部，可能还有一系列其他对象，该对象可经由此方法将能够处理某选择子的相关内部对象返回，这样的话，在外界看来，好像是该对象亲自处理了这些消息似的。

请注意，我们无法操作经由这一步所转发的消息。如果是想在发送给备援接收者之前先修改消息内容，那就得通过完整的消息转发机制来完成了。










