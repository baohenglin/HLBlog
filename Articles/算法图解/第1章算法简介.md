# 第一章 算法简介

算法是一组完成任务的指令。任何代码片段都可视为算法。

## 1.1 二分查找

二分查找是一种算法，其查找的列表必须是一个**有序**的元素列表。使用二分查找时，每次都排除一半的元素。一般而言，对于包含n个元素的列表，用二分查
找最多需要log<sub>2</sub>n步，而简单查找最多需要n步。

仅当列表是有序的时候，二分查找才管用。例如，电话簿中的名字是按字母顺序排列的， 因此可以使用二分查找来查找名字。

```
def binary_search(list, item):
    low = 0
    high = len(list)-1
    #只要范围没有缩小到只包含一个元素，就继续循环
    while low <= high:
        mid = (int)((low + high) / 2)
        guess = list[mid]
        if guess == item:
            return mid
        if guess > item:
            high = mid - 1
        else:
            low = mid + 1
    #注意缩进的格数，否则程序出错。
    return None


my_list = [1, 3, 5, 7, 9, 11] 
print(binary_search(my_list, 3))
```

## 1.2 运行时间

每次介绍算法时，我都将讨论其运行时间。一般而言，应选择效率最高的算 法，以最大限度地减少运行时间或占用空间。

回到前面的二分查找。使用它可节省多少时间呢?简单查找逐个地检查数 字，如果列表包含100个数字，最多需要猜100次。如果列表包含40亿个数字，最 多需要猜40亿次。换言之，最多需要猜测的次数与列表长度相同，这被称为线性 时间(linear time)。

二分查找则不同。如果列表包含100个元素，最多要猜7次;如果列表包含40亿个数字，最多 需猜32次。厉害吧?二分查找的运行时间为对数时间(或log时间)。

## 1.3 大O表示法

大O表示法是一种特殊的表示法，指出了算法的速度有多快。例如，假设列表包含n个元素。简 单查找需要检查每个元素，因此需要执行n次操作。使用大O表示法， 这个运行时间为O(n)。为检查长度为n的列表，二分查找需要执行log n次操作。使用大O表示法， 这个运行时间怎么表示呢?O(log n)。大O后面括号内的数表示操作数。大O表示法计算的是操作数。

**一些常见的大O运行时间**

下面按从快到慢的顺序列出了你经常会遇到的5种大O运行时间。

* O(log n)，也叫对数时间，这样的算法包括二分查找;
* O(n)，也叫线性时间，这样的算法包括简单查找;
* O(n * log n)，这样的算法包括快速排序——一种速度较快的排序算法;
* O(n2)，这样的算法包括选择排序——一种速度较慢的排序算法;
* O(n!)，n的阶乘，这样的算法包括接下来将介绍的旅行商问题的解决方案——一种非常慢的算法。这个算法要解决的是计算机科学领域非常著名的旅行商问题，其 计算时间增加得非常快。

需要特别注意的是：

* 算法的速度指的并非时间，而是操作数的增速。
* 谈论算法的速度时，我们说的是随着输入的增加，其运行时间将以什么样的速度增加。
* O(log n)比O(n)快，当需要搜索的元素越多时，前者比后者快得越多。
* 算法的速度指的并非时间，而是操作数的增速。

## 1.4 本章小结

* 二分查找的速度比简单查找快得多。
* O(log n)比O(n)快。需要搜索的元素越多，前者比后者就快得越多。
* 算法运行时间并不以秒为单位。
* 算法运行时间是从其增速的角度度量的。
* 算法运行时间用大O表示法表示。





