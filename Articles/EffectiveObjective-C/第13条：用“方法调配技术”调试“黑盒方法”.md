# 用“方法调配技术”调试“黑盒方法”

第11条中解释过：Objective-C对象收到消息之后，究竟会调用何种方法需要在运行期才能解析出来。那你也许会问：与给定的选择子名称相对应的方法是不是也可以在运行期改变呢？没错，就是这样。若能善用此特性，则可发挥出巨大优势，因为我们既不需要源代码，也不需要通过继承子类来覆写方法就能改变这个类本身的功能。这样一来，新功能将在本类的所有实例中生效，而不是仅限于覆写相关方法的那些子类实例。此方案经常称为“方法调配”(method swizzling)。

类的方法列表会把选择子的名称映射到相关的方法实现之上，使得“动态消息派发系统”能够据此找到应该调用的方法。这些方法均以函数指针的形式来表示，这种指针叫做IMP，其原型如下：

```
id (*IMP)(id, SEL, ...)
```

怎么互换两个已经写好的方法实现？交换方法实现，可用下列函数：

```
void method_exchangeImplementations(Method m1, Method m2)
```

此函数的两个参数表示待交换的两个方法实现，而方法实现可通过下列函数获得：

```
Method class_getInstanceMethod(Class aClass, SEL aSelector)
```

执行下列代码，即可交换前面提到的lowercaseString与uppercaseString方法实现：

```
Method originalMethod = class_getInstanceMethod([NSString class], @selector(lowercaseString));
Method swappedMethod = class_getInstanceMethod([NSString class], @selector(uppercaseString));
method_exchangeImplementations(originalMethod, swappedMethod);
```

那么现在调用lowercaseString，将执行uppercaseString的原有实现，反之亦然。

