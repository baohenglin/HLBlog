### 《编写高质量iOS与OS+X代码的52个有效方法》读书笔记
## *第5章 内存管理*
&emsp;&emsp;在Objective-C这种面向对象语言里，内存管理是一个重要的概念。要想用一门语言写出内存使用效率高而且又没有bug的代码，就得掌握其内存管理模型的种种细节。

&emsp;&emsp;自从iOS5开始引入了“自动引用计数”(Automatic Reference Counting,ARC)之后，内存管理就变得更为简单了。ARC几乎把所有内存管理事宜都交由编译器来决定，开发者只需要专注于业务逻辑。
### 第29条 理解引用计数
要点:

* 引用计数机制通过可以递增递减的计数器来管理内存。对象创建好之后，其引用计数至少为1。若引用计数为正数，则对象继续存活。当引用计数降为0时，对象就被销毁了。
* 在对象生命周期中，其余对象通过引用来保留或释放此对象。保留与释放操作分别会递增以及递减引用计数。

#### 29.1 什么是自动引用计数？

&emsp;&emsp;顾明思义，自动引用计数（ARC，Automatic Reference Counting）是指内存管理中对引用采取自动计数的技术。以下摘自苹果的官方说明：

&emsp;&emsp;在Objective-C中采用Automatic Reference Counting（ARC）机制，让编译器来进行内存管理。在新一代Apple LLVM编译器中设置ARC为有效状态，就无需再次键入retain或者release代码，这在降低程序崩溃、内存泄漏等风险的同时，很大程度上减少了开发程序的工作量。编译器完全清楚目标对象，并能立刻释放那些不再被使用的对象。如此一来，应用程序将具有可预测性，且能流畅运行，速度也将大幅提升。

&emsp;&emsp;换言之，若满足以下条件，就无需手动输入retain和release代码了。

* 使用Xcode4.2或以上版本
+ 使用LLVM编译器3.0或以上版本
- 编译器选项中设置ARC有效

&emsp;&emsp;在以上条件下编译源代码时，编译器将自动进行内存管理。
#### 29.2 引用计数的工作原理（思考方式）

&emsp;&emsp;内存管理的思考方式如下：

* （1）自己生成的对象，自己所持有；
* （2）非自己生成的对象，自己也能持有；
* （3）不再需要自己持有的对象时，释放；
* （4）非自己持有的对象，无法释放。

&emsp;&emsp;对象操作与Objective-C方法的对应如下：

对象操作 | Objective-C 方法 |
:--|:--
生成并持有对象 | alloc/new/copy/mutableCopy等方法
持有对象 | retain 方法 
释放对象 | release 方法
废弃对象 | dealloc 方法

【注意】Objective-C内存管理中的alloc/retain/release/dealloc方法分别指代NSSObject类的alloc类方法、retain实例方法、release实例方法和dealloc实例方法。

#### 29.3 属性存取方法中的内存管理

&emsp;&emsp;访问属性时，会用到相关实例变量的获取方法及设置方法。若属性为“strong关系”(strong relationship)，则设置的属性值会保留。例如，有个名叫foo的属性由名为_foo的实例变量所实现，那么，该属性的设置方法如下：

```
- (void)setFoo:(id)foo
{
	[foo retain];
	[_foo release];
	_foo = foo;
}
```
以上方法将保留新值并释放旧值，然后更新实例变量，令其指向新值。顺序很重要。假如还未保留新值就先把旧值释放了，而且两个值又指向同一个对象，那么先执行的release操作就可能导致系统将此对象永久回收（销毁）。而后续的retain操作则无法令这个已经彻底回收的对象复生，于是实例变量就变成了悬挂指针（指向无效对象的指针称为“悬挂指针”，也称为迷途指针或悬摆指针）。

#### 29.4 循环引用/保留环（retain cycle）

&emsp;&emsp;使用自动引用计数机制（ARC）时，要注意循环引用的问题。循环引用最简单的情况是两个或两个以上的对象之间呈环状相互强引用。比如对象A强引用了对象B，同时对象B又强引用了对象A，双方都同时保持着对对方的强引用，导致双方引用计数都不能变为0，始终无法释放。如果存在循环引用，那么将导致内存泄漏。

##### 容易导致循环引用的四个场景：

* （1）两个视图控制器间或者父类与子类间传递Controller参数；
* （2）block。该类将block作为自己的属性，而该类在block的方法体内部又引用了该类，此时会导致循环引用；
* （3）Delegate；
* （4）NSTimer；